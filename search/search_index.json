{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TNaLaGmes TNaLaGmes is a Toolbox for Natural Language Games I asked myself, what if random python objects could talk to you using only natural language? TNaLaGmes is a library that provides tools and default models for a variety of constructs, it was made thinking about games, but it really is about text enabling random code constructs! Read the Wiki early alpha version on pip install pip install TNaLaGmes Usage to play the original oregon trail from tnalagmes.games import OregonTrail game = OregonTrail() game.run() or maybe you prefer a zombie survival game from tnalagmes.games.zombie import ZVirus game = ZVirus() game.run() Chatbot agents are provided via all_the_chatbots , you need internet for this from tnalagmes.models.agents import Mitsuku # notable chat agents can be imported directly from tnalagmes.models.agents import ChatAgent # you can create your own and override on_turn hitler = ChatAgent.create_agent(\"hitler\") # get an agent from all_the_chatbots Mitsuku.run() # output bellow > My name is Mitsuku. hello > Hi there. How are you? tell me a joke > My mates been drinking brake fluid for 6 years but he says he's not addicted. He reckons he can stop anytime he wants. > Thanks for the information. do you believe in god? > <image>http://www.square-bear.co.uk/mitsuku/gallery/god.jpg</image> > I believe there is probably something out there but I doubt it is a man with a long beard sat on a throne. to do something useful as part of a project look how i made a Calendar class Calendar(TNaLaGmesConstruct): \"\"\" Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\" \"\"\" # standard python functionality, implementing date and turn tracking for our calendar def __init__(self, total_turns=20, start_date=None, turn_delta=0): TNaLaGmesConstruct.__init__(self, \"calendar\") # pass a string with object_type if desired self._date = start_date or datetime.now() self.days_per_turn = turn_delta self._turn_delta = timedelta(days=self.days_per_turn) if self.days_per_turn else None self._turn_count = 1 self._max_turns = total_turns def change_speed(self, days_per_turn=0): if isinstance(days_per_turn, str): if days_per_turn.strip().lower().startswith(\"easy\"): days_per_turn = 1 elif days_per_turn.strip().lower().startswith(\"hard\"): days_per_turn = 14 days_per_turn = self.extract_number(days_per_turn) self._turn_delta = timedelta(days_per_turn) def advance_date(self): if self._turn_delta is None: self._date = datetime.now() return self._date += self._turn_delta self._turn_count += 1 def rollback_date(self, rollback_days=None): rollback_days = rollback_days or self.days_per_turn self._date -= timedelta(days=rollback_days) @property def weekday(self): day = self._date.weekday() if day == 0: return \"Monday\" elif day == 1: return \"Tuesday\" elif day == 2: return \"Wednesday\" elif day == 3: return \"Thursday\" elif day == 4: return \"Friday\" elif day == 5: return \"Saturday\" elif day == 6: return \"Sunday\" return \"What kind of calendar is this? \" @property def pretty_date(self): return self.weekday + \" \" + self._date.strftime('%d, %b %Y') @property def is_final_turn(self): if not self._turn_delta: return False if self._turn_count >= self._max_turns: return True else: return False @property def turns(self): return self._turn_count @property def date(self): return self._date @property def max_turns(self): return self._max_turns @property def week_of_month(self): # https://en.wikipedia.org/wiki/ISO_week_date#Weeks_per_month first_day = self.date.replace(day=1) day_of_month = self.date.day # adjust for sundays if (first_day.weekday() == 6): adjusted_dom = (1 + first_day.weekday()) / 7 else: adjusted_dom = day_of_month + first_day.weekday() # days may belong to a month but their week may belong to another one # weeks belong to a month if its thursday falls on it if (first_day.weekday() > 3): return int(ceil(adjusted_dom / 7.0)) - 1 else: return int(ceil(adjusted_dom / 7.0)) # in here register the word triggers # im only using keyword rules instead of sample phrases # literal strings are used as keywords # if available on locale folder vocabulary is expanded def register_core_intents(self): self.register_keyword_intent(\"advance\", required=[\"date\", \"advance\"], optionals=[], handler=self.handle_advance) self.register_keyword_intent(\"rollback\", required=[\"rollback\", \"date\"], optionals=[], handler=self.handle_rollback) self.register_keyword_intent(\"speed_decrease\", required=[\"decrease\", \"speed\"], optionals=[], handler=self.handle_speed_decrease) self.register_keyword_intent(\"speed_increase\", required=[\"increase\", \"speed\"], optionals=[], handler=self.handle_speed_increase) self.register_keyword_intent(\"days_per_turn\", required=[\"turns\", \"day\"], optionals=[\"question\"], handler=self.handle_days_per_turn) self.register_keyword_intent(\"turns_max\", required=[\"turns\", \"total\"], optionals=[\"question\"], handler=self.handle_turns_max) self.register_keyword_intent(\"turns_past\", required=[\"turns\", \"past\"], optionals=[\"question\"], handler=self.handle_turns_past) self.register_keyword_intent(\"turns_current\", required=[\"turns\", \"current\"], optionals=[\"question\"], handler=self.handle_turns_current) self.register_keyword_intent(\"turns_left\", required=[\"turns\", \"remaining\"], optionals=[\"question\"], handler=self.handle_turns_left) self.register_keyword_intent(\"next_turn\", required=[\"next\", \"turn\"], optionals=[], handler=self.handle_next_turn) self.register_keyword_intent(\"ask_day\", required=[\"day\"], optionals=[\"question\"], handler=self.handle_day) self.register_keyword_intent(\"ask_week\", required=[\"week\"], optionals=[\"question\"], handler=self.handle_week) self.register_keyword_intent(\"ask_weekday\", required=[\"weekday\"], optionals=[\"question\"], handler=self.handle_weekday) self.register_keyword_intent(\"ask_month\", required=[\"month\"], optionals=[\"question\"], handler=self.handle_month) self.register_keyword_intent(\"ask_year\", required=[\"year\"], optionals=[\"question\"], handler=self.handle_year) self.register_keyword_intent(\"ask_date\", required=[\"date\"], optionals=[\"question\"], handler=self.handle_date) # handlers for each natural language questions def handle_date(self, intent): return self.pretty_date def handle_week(self, intent): # TODO util to pronounce cardinals return \"it is the \" + str(self.week_of_month) + \" week of the month\" def handle_weekday(self, intent): return self.weekday def handle_month(self, intent): return str(self.date.month) def handle_day(self, intent): return str(self.date.day) def handle_year(self, intent): return \"it is the year \" + str(self.date.year) def handle_days_per_turn(self, intent): return str(self._turn_delta) + \" days per turn\" def handle_turns_left(self, intent): return \"you have \" + str(self.max_turns - self.turns) + \" left\" def handle_turns_max(self, intent): return \"maximum number of turns is \" + str(self.max_turns) def handle_turns_current(self, intent): return \"currently in turn\" + str(self.turns) def handle_turns_past(self, intent): return str(self.turns - 1) + \" passed\" def handle_next_turn(self, intent): self.advance_date() return \"now in turn\" + str(self.turns) def handle_advance(self, intent): self.advance_date() return \"advanced date by \" + str(self._turn_delta) + \" days\" def handle_rollback(self, intent): number = self.extract_number(intent[\"utterance\"]) self.rollback_date(number) return \"rolled back date by \" + str(number) + \" days\" def handle_speed_decrease(self, intent): number = self.extract_number(intent[\"utterance\"]) number = number or 1 self.change_speed(self._turn_delta - number) return \"decreased speed by \" + str(number) + \" days\" def handle_speed_increase(self, intent): number = self.extract_number(intent[\"utterance\"]) number = number or 1 self.change_speed(self._turn_delta - number) return \"increased speed by \" + str(number) + \" days\" you can interact with it now if __name__ == \"__main__\": construct = Calendar() print(construct.parse_command(\"current date\")) print(construct.parse_command(\"what day\")) print(construct.parse_command(\"what month\")) print(construct.parse_command(\"what weekday\")) print(construct.parse_command(\"total turns\")) # Saturday 13, Oct 2018 # 13 # 10 # Saturday # maximum number of turns is 20","title":"Home"},{"location":"#tnalagmes","text":"TNaLaGmes is a Toolbox for Natural Language Games I asked myself, what if random python objects could talk to you using only natural language? TNaLaGmes is a library that provides tools and default models for a variety of constructs, it was made thinking about games, but it really is about text enabling random code constructs! Read the Wiki early alpha version on pip","title":"TNaLaGmes"},{"location":"#install","text":"pip install TNaLaGmes","title":"install"},{"location":"#usage","text":"to play the original oregon trail from tnalagmes.games import OregonTrail game = OregonTrail() game.run() or maybe you prefer a zombie survival game from tnalagmes.games.zombie import ZVirus game = ZVirus() game.run() Chatbot agents are provided via all_the_chatbots , you need internet for this from tnalagmes.models.agents import Mitsuku # notable chat agents can be imported directly from tnalagmes.models.agents import ChatAgent # you can create your own and override on_turn hitler = ChatAgent.create_agent(\"hitler\") # get an agent from all_the_chatbots Mitsuku.run() # output bellow > My name is Mitsuku. hello > Hi there. How are you? tell me a joke > My mates been drinking brake fluid for 6 years but he says he's not addicted. He reckons he can stop anytime he wants. > Thanks for the information. do you believe in god? > <image>http://www.square-bear.co.uk/mitsuku/gallery/god.jpg</image> > I believe there is probably something out there but I doubt it is a man with a long beard sat on a throne. to do something useful as part of a project look how i made a Calendar class Calendar(TNaLaGmesConstruct): \"\"\" Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\" \"\"\" # standard python functionality, implementing date and turn tracking for our calendar def __init__(self, total_turns=20, start_date=None, turn_delta=0): TNaLaGmesConstruct.__init__(self, \"calendar\") # pass a string with object_type if desired self._date = start_date or datetime.now() self.days_per_turn = turn_delta self._turn_delta = timedelta(days=self.days_per_turn) if self.days_per_turn else None self._turn_count = 1 self._max_turns = total_turns def change_speed(self, days_per_turn=0): if isinstance(days_per_turn, str): if days_per_turn.strip().lower().startswith(\"easy\"): days_per_turn = 1 elif days_per_turn.strip().lower().startswith(\"hard\"): days_per_turn = 14 days_per_turn = self.extract_number(days_per_turn) self._turn_delta = timedelta(days_per_turn) def advance_date(self): if self._turn_delta is None: self._date = datetime.now() return self._date += self._turn_delta self._turn_count += 1 def rollback_date(self, rollback_days=None): rollback_days = rollback_days or self.days_per_turn self._date -= timedelta(days=rollback_days) @property def weekday(self): day = self._date.weekday() if day == 0: return \"Monday\" elif day == 1: return \"Tuesday\" elif day == 2: return \"Wednesday\" elif day == 3: return \"Thursday\" elif day == 4: return \"Friday\" elif day == 5: return \"Saturday\" elif day == 6: return \"Sunday\" return \"What kind of calendar is this? \" @property def pretty_date(self): return self.weekday + \" \" + self._date.strftime('%d, %b %Y') @property def is_final_turn(self): if not self._turn_delta: return False if self._turn_count >= self._max_turns: return True else: return False @property def turns(self): return self._turn_count @property def date(self): return self._date @property def max_turns(self): return self._max_turns @property def week_of_month(self): # https://en.wikipedia.org/wiki/ISO_week_date#Weeks_per_month first_day = self.date.replace(day=1) day_of_month = self.date.day # adjust for sundays if (first_day.weekday() == 6): adjusted_dom = (1 + first_day.weekday()) / 7 else: adjusted_dom = day_of_month + first_day.weekday() # days may belong to a month but their week may belong to another one # weeks belong to a month if its thursday falls on it if (first_day.weekday() > 3): return int(ceil(adjusted_dom / 7.0)) - 1 else: return int(ceil(adjusted_dom / 7.0)) # in here register the word triggers # im only using keyword rules instead of sample phrases # literal strings are used as keywords # if available on locale folder vocabulary is expanded def register_core_intents(self): self.register_keyword_intent(\"advance\", required=[\"date\", \"advance\"], optionals=[], handler=self.handle_advance) self.register_keyword_intent(\"rollback\", required=[\"rollback\", \"date\"], optionals=[], handler=self.handle_rollback) self.register_keyword_intent(\"speed_decrease\", required=[\"decrease\", \"speed\"], optionals=[], handler=self.handle_speed_decrease) self.register_keyword_intent(\"speed_increase\", required=[\"increase\", \"speed\"], optionals=[], handler=self.handle_speed_increase) self.register_keyword_intent(\"days_per_turn\", required=[\"turns\", \"day\"], optionals=[\"question\"], handler=self.handle_days_per_turn) self.register_keyword_intent(\"turns_max\", required=[\"turns\", \"total\"], optionals=[\"question\"], handler=self.handle_turns_max) self.register_keyword_intent(\"turns_past\", required=[\"turns\", \"past\"], optionals=[\"question\"], handler=self.handle_turns_past) self.register_keyword_intent(\"turns_current\", required=[\"turns\", \"current\"], optionals=[\"question\"], handler=self.handle_turns_current) self.register_keyword_intent(\"turns_left\", required=[\"turns\", \"remaining\"], optionals=[\"question\"], handler=self.handle_turns_left) self.register_keyword_intent(\"next_turn\", required=[\"next\", \"turn\"], optionals=[], handler=self.handle_next_turn) self.register_keyword_intent(\"ask_day\", required=[\"day\"], optionals=[\"question\"], handler=self.handle_day) self.register_keyword_intent(\"ask_week\", required=[\"week\"], optionals=[\"question\"], handler=self.handle_week) self.register_keyword_intent(\"ask_weekday\", required=[\"weekday\"], optionals=[\"question\"], handler=self.handle_weekday) self.register_keyword_intent(\"ask_month\", required=[\"month\"], optionals=[\"question\"], handler=self.handle_month) self.register_keyword_intent(\"ask_year\", required=[\"year\"], optionals=[\"question\"], handler=self.handle_year) self.register_keyword_intent(\"ask_date\", required=[\"date\"], optionals=[\"question\"], handler=self.handle_date) # handlers for each natural language questions def handle_date(self, intent): return self.pretty_date def handle_week(self, intent): # TODO util to pronounce cardinals return \"it is the \" + str(self.week_of_month) + \" week of the month\" def handle_weekday(self, intent): return self.weekday def handle_month(self, intent): return str(self.date.month) def handle_day(self, intent): return str(self.date.day) def handle_year(self, intent): return \"it is the year \" + str(self.date.year) def handle_days_per_turn(self, intent): return str(self._turn_delta) + \" days per turn\" def handle_turns_left(self, intent): return \"you have \" + str(self.max_turns - self.turns) + \" left\" def handle_turns_max(self, intent): return \"maximum number of turns is \" + str(self.max_turns) def handle_turns_current(self, intent): return \"currently in turn\" + str(self.turns) def handle_turns_past(self, intent): return str(self.turns - 1) + \" passed\" def handle_next_turn(self, intent): self.advance_date() return \"now in turn\" + str(self.turns) def handle_advance(self, intent): self.advance_date() return \"advanced date by \" + str(self._turn_delta) + \" days\" def handle_rollback(self, intent): number = self.extract_number(intent[\"utterance\"]) self.rollback_date(number) return \"rolled back date by \" + str(number) + \" days\" def handle_speed_decrease(self, intent): number = self.extract_number(intent[\"utterance\"]) number = number or 1 self.change_speed(self._turn_delta - number) return \"decreased speed by \" + str(number) + \" days\" def handle_speed_increase(self, intent): number = self.extract_number(intent[\"utterance\"]) number = number or 1 self.change_speed(self._turn_delta - number) return \"increased speed by \" + str(number) + \" days\" you can interact with it now if __name__ == \"__main__\": construct = Calendar() print(construct.parse_command(\"current date\")) print(construct.parse_command(\"what day\")) print(construct.parse_command(\"what month\")) print(construct.parse_command(\"what weekday\")) print(construct.parse_command(\"total turns\")) # Saturday 13, Oct 2018 # 13 # 10 # Saturday # maximum number of turns is 20","title":"Usage"},{"location":"engines/","text":"tnalagmes/engines Technical Reference Guide auto generated on 2018-10-16 01:51:34 Contents tnalagmes/engines/textadventurer.py tnalagmes/engines/intentworld.py tnalagmes/engines/textwarrior.py tnalagmes/engines/oregon75.py tnalagmes/engines/oregon.py tnalagmes/engines/oregon78.py tnalagmes/engines/textadventurer.py source file tnalagmes/engines/intentworld.py source file tnalagmes/engines/textwarrior.py source file tnalagmes/engines/oregon75.py source file tnalagmes/engines/oregon.py source file tnalagmes/engines/oregon78.py source file","title":"engines"},{"location":"engines/#tnalagmesengines-technical-reference-guide","text":"auto generated on 2018-10-16 01:51:34","title":"tnalagmes/engines Technical Reference Guide"},{"location":"engines/#contents","text":"tnalagmes/engines/textadventurer.py tnalagmes/engines/intentworld.py tnalagmes/engines/textwarrior.py tnalagmes/engines/oregon75.py tnalagmes/engines/oregon.py tnalagmes/engines/oregon78.py","title":"Contents"},{"location":"engines/#tnalagmesenginestextadventurerpy","text":"source file","title":"tnalagmes/engines/textadventurer.py"},{"location":"engines/#tnalagmesenginesintentworldpy","text":"source file","title":"tnalagmes/engines/intentworld.py"},{"location":"engines/#tnalagmesenginestextwarriorpy","text":"source file","title":"tnalagmes/engines/textwarrior.py"},{"location":"engines/#tnalagmesenginesoregon75py","text":"source file","title":"tnalagmes/engines/oregon75.py"},{"location":"engines/#tnalagmesenginesoregonpy","text":"source file","title":"tnalagmes/engines/oregon.py"},{"location":"engines/#tnalagmesenginesoregon78py","text":"source file","title":"tnalagmes/engines/oregon78.py"},{"location":"games/","text":"tnalagmes/games Technical Reference Guide auto generated on 2018-10-16 01:51:34 Contents tnalagmes/games/dummy.py tnalagmes/games/zombie.py tnalagmes/games/oregon_trail.py tnalagmes/games/dummy.py source file tnalagmes/games/zombie.py source file tnalagmes/games/oregon_trail.py source file","title":"games"},{"location":"games/#tnalagmesgames-technical-reference-guide","text":"auto generated on 2018-10-16 01:51:34","title":"tnalagmes/games Technical Reference Guide"},{"location":"games/#contents","text":"tnalagmes/games/dummy.py tnalagmes/games/zombie.py tnalagmes/games/oregon_trail.py","title":"Contents"},{"location":"games/#tnalagmesgamesdummypy","text":"source file","title":"tnalagmes/games/dummy.py"},{"location":"games/#tnalagmesgameszombiepy","text":"source file","title":"tnalagmes/games/zombie.py"},{"location":"games/#tnalagmesgamesoregon_trailpy","text":"source file","title":"tnalagmes/games/oregon_trail.py"},{"location":"intents/","text":"tnalagmes/intents Technical Reference Guide auto generated on 2018-10-16 01:51:34","title":"intents"},{"location":"intents/#tnalagmesintents-technical-reference-guide","text":"auto generated on 2018-10-16 01:51:34","title":"tnalagmes/intents Technical Reference Guide"},{"location":"models/","text":"tnalagmes/models Technical Reference Guide auto generated on 2018-10-16 01:51:34 Contents tnalagmes/models/objects.py tnalagmes/models/agents.py tnalagmes/models/world.py tnalagmes/models/battle.py tnalagmes/models/objects.py source file tnalagmes/models/agents.py source file tnalagmes/models/world.py source file tnalagmes/models/battle.py source file","title":"models"},{"location":"models/#tnalagmesmodels-technical-reference-guide","text":"auto generated on 2018-10-16 01:51:34","title":"tnalagmes/models Technical Reference Guide"},{"location":"models/#contents","text":"tnalagmes/models/objects.py tnalagmes/models/agents.py tnalagmes/models/world.py tnalagmes/models/battle.py","title":"Contents"},{"location":"models/#tnalagmesmodelsobjectspy","text":"source file","title":"tnalagmes/models/objects.py"},{"location":"models/#tnalagmesmodelsagentspy","text":"source file","title":"tnalagmes/models/agents.py"},{"location":"models/#tnalagmesmodelsworldpy","text":"source file","title":"tnalagmes/models/world.py"},{"location":"models/#tnalagmesmodelsbattlepy","text":"source file","title":"tnalagmes/models/battle.py"},{"location":"oregontrail_original/","text":"tnalagmes/games/oregon_trail Technical Reference Guide auto generated on 2018-10-16 01:51:34","title":"oregontrail_original"},{"location":"oregontrail_original/#tnalagmesgamesoregon_trail-technical-reference-guide","text":"auto generated on 2018-10-16 01:51:34","title":"tnalagmes/games/oregon_trail Technical Reference Guide"},{"location":"engines/oregon75/","text":"tnalagmes/engines/oregon75 Technical Reference Guide auto generated on 2018-10-16 01:51:34","title":"oregon75"},{"location":"engines/oregon75/#tnalagmesenginesoregon75-technical-reference-guide","text":"auto generated on 2018-10-16 01:51:34","title":"tnalagmes/engines/oregon75 Technical Reference Guide"},{"location":"models/agents/","text":"tnalagmes/models/agents Technical Reference Guide auto generated on 2018-10-16 01:51:34","title":"agents"},{"location":"models/agents/#tnalagmesmodelsagents-technical-reference-guide","text":"auto generated on 2018-10-16 01:51:34","title":"tnalagmes/models/agents Technical Reference Guide"},{"location":"models/objects/","text":"tnalagmes/models/objects Technical Reference Guide auto generated on 2018-10-16 01:51:34","title":"objects"},{"location":"models/objects/#tnalagmesmodelsobjects-technical-reference-guide","text":"auto generated on 2018-10-16 01:51:34","title":"tnalagmes/models/objects Technical Reference Guide"},{"location":"models/util/","text":"tnalagmes/util Technical Reference Guide auto generated on 2018-10-16 01:51:34 Contents tnalagmes/util/log.py tnalagmes/util/signal.py tnalagmes/util/phonemes.py tnalagmes/util/nlp.py tnalagmes/util/time.py tnalagmes/util/log.py source file getLogger getLogger(name=\"TNALAGMES\") Depreciated. Use LOG instead _make_log_method _make_log_method(fn) tnalagmes/util/signal.py source file get_ipc_directory get_ipc_directory(domain=None, dir=None) Get the directory used for Inter Process Communication Files in this folder can be accessed by different processes on the machine. Useful for communication. This is often a small RAM disk. Args: domain (str): The IPC domain. Basically a subdirectory to prevent overlapping signal filenames. Returns: str: a path to the IPC directory ensure_directory_exists ensure_directory_exists(directory, domain=None) Create a directory and give access rights to all Args: domain (str): The IPC domain. Basically a subdirectory to prevent overlapping signal filenames. Returns: str: a path to the directory create_file create_file(filename) Create the file filename and create any directories needed Args: filename: Path to the file to be created create_signal create_signal(signal_name) Create a named signal Args: signal_name (str): The signal's name. Must only contain characters valid in filenames. check_for_signal check_for_signal(signal_name, sec_lifetime=0) See if a named signal exists Args: signal_name (str): The signal's name. Must only contain characters valid in filenames. sec_lifetime (int, optional): How many seconds the signal should remain valid. If 0 or not specified, it is a single-use signal. If -1, it never expires. Returns: bool: True if the signal is defined, False otherwise tnalagmes/util/phonemes.py source file guess_phonemes guess_phonemes(word, lang=\"en-us\") get_phonemes get_phonemes(name, lang=\"en-us\") tnalagmes/util/nlp.py source file NER NER(text) replace_coreferences replace_coreferences(text) textual_entailment textual_entailment(premise, hypothesis) tnalagmes/util/time.py source file default_timezone default_timezone() Get the default timezone Based on user location settings location.timezone.code or the default system value if no setting exists. Returns: (datetime.tzinfo): Definition of the default timezone now_utc now_utc() Retrieve the current time in UTC Returns: (datetime): The current time in Universal Time, aka GMT now_local now_local(tz=None) Retrieve the current time Args: tz (datetime.tzinfo, optional): Timezone, default to user's settings Returns: (datetime): The current time to_utc to_utc(dt) Convert a datetime with timezone info to a UTC datetime Args: dt (datetime): A datetime (presumably in some local zone) Returns: (datetime): time converted to UTC to_local to_local(dt) Convert a datetime to the user's local timezone Args: dt (datetime): A datetime (if no timezone, defaults to UTC) Returns: (datetime): time converted to the local timezone get_timedelta get_timedelta(dt, anchor=None) Get a datetime object or a int() Epoch timestamp and return a timedelta","title":"util"},{"location":"models/util/#tnalagmesutil-technical-reference-guide","text":"auto generated on 2018-10-16 01:51:34","title":"tnalagmes/util Technical Reference Guide"},{"location":"models/util/#contents","text":"tnalagmes/util/log.py tnalagmes/util/signal.py tnalagmes/util/phonemes.py tnalagmes/util/nlp.py tnalagmes/util/time.py","title":"Contents"},{"location":"models/util/#tnalagmesutillogpy","text":"source file","title":"tnalagmes/util/log.py"},{"location":"models/util/#getlogger","text":"getLogger(name=\"TNALAGMES\") Depreciated. Use LOG instead","title":"getLogger"},{"location":"models/util/#_make_log_method","text":"_make_log_method(fn)","title":"_make_log_method"},{"location":"models/util/#tnalagmesutilsignalpy","text":"source file","title":"tnalagmes/util/signal.py"},{"location":"models/util/#get_ipc_directory","text":"get_ipc_directory(domain=None, dir=None) Get the directory used for Inter Process Communication Files in this folder can be accessed by different processes on the machine. Useful for communication. This is often a small RAM disk. Args: domain (str): The IPC domain. Basically a subdirectory to prevent overlapping signal filenames. Returns: str: a path to the IPC directory","title":"get_ipc_directory"},{"location":"models/util/#ensure_directory_exists","text":"ensure_directory_exists(directory, domain=None) Create a directory and give access rights to all Args: domain (str): The IPC domain. Basically a subdirectory to prevent overlapping signal filenames. Returns: str: a path to the directory","title":"ensure_directory_exists"},{"location":"models/util/#create_file","text":"create_file(filename) Create the file filename and create any directories needed Args: filename: Path to the file to be created","title":"create_file"},{"location":"models/util/#create_signal","text":"create_signal(signal_name) Create a named signal Args: signal_name (str): The signal's name. Must only contain characters valid in filenames.","title":"create_signal"},{"location":"models/util/#check_for_signal","text":"check_for_signal(signal_name, sec_lifetime=0) See if a named signal exists Args: signal_name (str): The signal's name. Must only contain characters valid in filenames. sec_lifetime (int, optional): How many seconds the signal should remain valid. If 0 or not specified, it is a single-use signal. If -1, it never expires. Returns: bool: True if the signal is defined, False otherwise","title":"check_for_signal"},{"location":"models/util/#tnalagmesutilphonemespy","text":"source file","title":"tnalagmes/util/phonemes.py"},{"location":"models/util/#guess_phonemes","text":"guess_phonemes(word, lang=\"en-us\")","title":"guess_phonemes"},{"location":"models/util/#get_phonemes","text":"get_phonemes(name, lang=\"en-us\")","title":"get_phonemes"},{"location":"models/util/#tnalagmesutilnlppy","text":"source file","title":"tnalagmes/util/nlp.py"},{"location":"models/util/#ner","text":"NER(text)","title":"NER"},{"location":"models/util/#replace_coreferences","text":"replace_coreferences(text)","title":"replace_coreferences"},{"location":"models/util/#textual_entailment","text":"textual_entailment(premise, hypothesis)","title":"textual_entailment"},{"location":"models/util/#tnalagmesutiltimepy","text":"source file","title":"tnalagmes/util/time.py"},{"location":"models/util/#default_timezone","text":"default_timezone() Get the default timezone Based on user location settings location.timezone.code or the default system value if no setting exists. Returns: (datetime.tzinfo): Definition of the default timezone","title":"default_timezone"},{"location":"models/util/#now_utc","text":"now_utc() Retrieve the current time in UTC Returns: (datetime): The current time in Universal Time, aka GMT","title":"now_utc"},{"location":"models/util/#now_local","text":"now_local(tz=None) Retrieve the current time Args: tz (datetime.tzinfo, optional): Timezone, default to user's settings Returns: (datetime): The current time","title":"now_local"},{"location":"models/util/#to_utc","text":"to_utc(dt) Convert a datetime with timezone info to a UTC datetime Args: dt (datetime): A datetime (presumably in some local zone) Returns: (datetime): time converted to UTC","title":"to_utc"},{"location":"models/util/#to_local","text":"to_local(dt) Convert a datetime to the user's local timezone Args: dt (datetime): A datetime (if no timezone, defaults to UTC) Returns: (datetime): time converted to the local timezone","title":"to_local"},{"location":"models/util/#get_timedelta","text":"get_timedelta(dt, anchor=None) Get a datetime object or a int() Epoch timestamp and return a timedelta","title":"get_timedelta"},{"location":"models/world/","text":"tnalagmes/models/world Technical Reference Guide auto generated on 2018-10-16 01:51:34","title":"world"},{"location":"models/world/#tnalagmesmodelsworld-technical-reference-guide","text":"auto generated on 2018-10-16 01:51:34","title":"tnalagmes/models/world Technical Reference Guide"}]}