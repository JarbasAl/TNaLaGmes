{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TNaLaGmes TNaLaGmes is a Toolbox for Natural Language Games I asked myself, what if random python objects could talk to you using only natural language? TNaLaGmes is a library that provides tools and default models for a variety of constructs, it was made thinking about games, but it really is about text enabling random code constructs! Read the Wiki early alpha version on pip install pip install TNaLaGmes Usage to play the original oregon trail from tnalagmes.games import OregonTrail game = OregonTrail() game.run() or maybe you prefer a zombie survival game from tnalagmes.games.zombie import ZVirus game = ZVirus() game.run() Chatbot agents are provided via all_the_chatbots , you need internet for this from tnalagmes.models.agents import Mitsuku # notable chat agents can be imported directly from tnalagmes.models.agents import ChatAgent # you can create your own and override on_turn hitler = ChatAgent.create_agent(\"hitler\") # get an agent from all_the_chatbots Mitsuku.run() # output bellow > My name is Mitsuku. hello > Hi there. How are you? tell me a joke > My mates been drinking brake fluid for 6 years but he says he's not addicted. He reckons he can stop anytime he wants. > Thanks for the information. do you believe in god? > <image>http://www.square-bear.co.uk/mitsuku/gallery/god.jpg</image> > I believe there is probably something out there but I doubt it is a man with a long beard sat on a throne. to do something useful as part of a project look how i made a Calendar class Calendar(TNaLaGmesConstruct): \"\"\" Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\" \"\"\" # standard python functionality, implementing date and turn tracking for our calendar def __init__(self, total_turns=20, start_date=None, turn_delta=0): TNaLaGmesConstruct.__init__(self, \"calendar\") # pass a string with object_type if desired self._date = start_date or datetime.now() self.days_per_turn = turn_delta self._turn_delta = timedelta(days=self.days_per_turn) if self.days_per_turn else None self._turn_count = 1 self._max_turns = total_turns def change_speed(self, days_per_turn=0): if isinstance(days_per_turn, str): if days_per_turn.strip().lower().startswith(\"easy\"): days_per_turn = 1 elif days_per_turn.strip().lower().startswith(\"hard\"): days_per_turn = 14 days_per_turn = self.extract_number(days_per_turn) self._turn_delta = timedelta(days_per_turn) def advance_date(self): if self._turn_delta is None: self._date = datetime.now() return self._date += self._turn_delta self._turn_count += 1 def rollback_date(self, rollback_days=None): rollback_days = rollback_days or self.days_per_turn self._date -= timedelta(days=rollback_days) @property def weekday(self): day = self._date.weekday() if day == 0: return \"Monday\" elif day == 1: return \"Tuesday\" elif day == 2: return \"Wednesday\" elif day == 3: return \"Thursday\" elif day == 4: return \"Friday\" elif day == 5: return \"Saturday\" elif day == 6: return \"Sunday\" return \"What kind of calendar is this? \" @property def pretty_date(self): return self.weekday + \" \" + self._date.strftime('%d, %b %Y') @property def is_final_turn(self): if not self._turn_delta: return False if self._turn_count >= self._max_turns: return True else: return False @property def turns(self): return self._turn_count @property def date(self): return self._date @property def max_turns(self): return self._max_turns @property def week_of_month(self): # https://en.wikipedia.org/wiki/ISO_week_date#Weeks_per_month first_day = self.date.replace(day=1) day_of_month = self.date.day # adjust for sundays if (first_day.weekday() == 6): adjusted_dom = (1 + first_day.weekday()) / 7 else: adjusted_dom = day_of_month + first_day.weekday() # days may belong to a month but their week may belong to another one # weeks belong to a month if its thursday falls on it if (first_day.weekday() > 3): return int(ceil(adjusted_dom / 7.0)) - 1 else: return int(ceil(adjusted_dom / 7.0)) # in here register the word triggers # im only using keyword rules instead of sample phrases # literal strings are used as keywords # if available on locale folder vocabulary is expanded def register_core_intents(self): self.register_keyword_intent(\"advance\", required=[\"date\", \"advance\"], optionals=[], handler=self.handle_advance) self.register_keyword_intent(\"rollback\", required=[\"rollback\", \"date\"], optionals=[], handler=self.handle_rollback) self.register_keyword_intent(\"speed_decrease\", required=[\"decrease\", \"speed\"], optionals=[], handler=self.handle_speed_decrease) self.register_keyword_intent(\"speed_increase\", required=[\"increase\", \"speed\"], optionals=[], handler=self.handle_speed_increase) self.register_keyword_intent(\"days_per_turn\", required=[\"turns\", \"day\"], optionals=[\"question\"], handler=self.handle_days_per_turn) self.register_keyword_intent(\"turns_max\", required=[\"turns\", \"total\"], optionals=[\"question\"], handler=self.handle_turns_max) self.register_keyword_intent(\"turns_past\", required=[\"turns\", \"past\"], optionals=[\"question\"], handler=self.handle_turns_past) self.register_keyword_intent(\"turns_current\", required=[\"turns\", \"current\"], optionals=[\"question\"], handler=self.handle_turns_current) self.register_keyword_intent(\"turns_left\", required=[\"turns\", \"remaining\"], optionals=[\"question\"], handler=self.handle_turns_left) self.register_keyword_intent(\"next_turn\", required=[\"next\", \"turn\"], optionals=[], handler=self.handle_next_turn) self.register_keyword_intent(\"ask_day\", required=[\"day\"], optionals=[\"question\"], handler=self.handle_day) self.register_keyword_intent(\"ask_week\", required=[\"week\"], optionals=[\"question\"], handler=self.handle_week) self.register_keyword_intent(\"ask_weekday\", required=[\"weekday\"], optionals=[\"question\"], handler=self.handle_weekday) self.register_keyword_intent(\"ask_month\", required=[\"month\"], optionals=[\"question\"], handler=self.handle_month) self.register_keyword_intent(\"ask_year\", required=[\"year\"], optionals=[\"question\"], handler=self.handle_year) self.register_keyword_intent(\"ask_date\", required=[\"date\"], optionals=[\"question\"], handler=self.handle_date) # handlers for each natural language questions def handle_date(self, intent): return self.pretty_date def handle_week(self, intent): # TODO util to pronounce cardinals return \"it is the \" + str(self.week_of_month) + \" week of the month\" def handle_weekday(self, intent): return self.weekday def handle_month(self, intent): return str(self.date.month) def handle_day(self, intent): return str(self.date.day) def handle_year(self, intent): return \"it is the year \" + str(self.date.year) def handle_days_per_turn(self, intent): return str(self._turn_delta) + \" days per turn\" def handle_turns_left(self, intent): return \"you have \" + str(self.max_turns - self.turns) + \" left\" def handle_turns_max(self, intent): return \"maximum number of turns is \" + str(self.max_turns) def handle_turns_current(self, intent): return \"currently in turn\" + str(self.turns) def handle_turns_past(self, intent): return str(self.turns - 1) + \" passed\" def handle_next_turn(self, intent): self.advance_date() return \"now in turn\" + str(self.turns) def handle_advance(self, intent): self.advance_date() return \"advanced date by \" + str(self._turn_delta) + \" days\" def handle_rollback(self, intent): number = self.extract_number(intent[\"utterance\"]) self.rollback_date(number) return \"rolled back date by \" + str(number) + \" days\" def handle_speed_decrease(self, intent): number = self.extract_number(intent[\"utterance\"]) number = number or 1 self.change_speed(self._turn_delta - number) return \"decreased speed by \" + str(number) + \" days\" def handle_speed_increase(self, intent): number = self.extract_number(intent[\"utterance\"]) number = number or 1 self.change_speed(self._turn_delta - number) return \"increased speed by \" + str(number) + \" days\" you can interact with it now if __name__ == \"__main__\": construct = Calendar() print(construct.parse_command(\"current date\")) print(construct.parse_command(\"what day\")) print(construct.parse_command(\"what month\")) print(construct.parse_command(\"what weekday\")) print(construct.parse_command(\"total turns\")) # Saturday 13, Oct 2018 # 13 # 10 # Saturday # maximum number of turns is 20","title":"Home"},{"location":"#tnalagmes","text":"TNaLaGmes is a Toolbox for Natural Language Games I asked myself, what if random python objects could talk to you using only natural language? TNaLaGmes is a library that provides tools and default models for a variety of constructs, it was made thinking about games, but it really is about text enabling random code constructs! Read the Wiki early alpha version on pip","title":"TNaLaGmes"},{"location":"#install","text":"pip install TNaLaGmes","title":"install"},{"location":"#usage","text":"to play the original oregon trail from tnalagmes.games import OregonTrail game = OregonTrail() game.run() or maybe you prefer a zombie survival game from tnalagmes.games.zombie import ZVirus game = ZVirus() game.run() Chatbot agents are provided via all_the_chatbots , you need internet for this from tnalagmes.models.agents import Mitsuku # notable chat agents can be imported directly from tnalagmes.models.agents import ChatAgent # you can create your own and override on_turn hitler = ChatAgent.create_agent(\"hitler\") # get an agent from all_the_chatbots Mitsuku.run() # output bellow > My name is Mitsuku. hello > Hi there. How are you? tell me a joke > My mates been drinking brake fluid for 6 years but he says he's not addicted. He reckons he can stop anytime he wants. > Thanks for the information. do you believe in god? > <image>http://www.square-bear.co.uk/mitsuku/gallery/god.jpg</image> > I believe there is probably something out there but I doubt it is a man with a long beard sat on a throne. to do something useful as part of a project look how i made a Calendar class Calendar(TNaLaGmesConstruct): \"\"\" Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\" \"\"\" # standard python functionality, implementing date and turn tracking for our calendar def __init__(self, total_turns=20, start_date=None, turn_delta=0): TNaLaGmesConstruct.__init__(self, \"calendar\") # pass a string with object_type if desired self._date = start_date or datetime.now() self.days_per_turn = turn_delta self._turn_delta = timedelta(days=self.days_per_turn) if self.days_per_turn else None self._turn_count = 1 self._max_turns = total_turns def change_speed(self, days_per_turn=0): if isinstance(days_per_turn, str): if days_per_turn.strip().lower().startswith(\"easy\"): days_per_turn = 1 elif days_per_turn.strip().lower().startswith(\"hard\"): days_per_turn = 14 days_per_turn = self.extract_number(days_per_turn) self._turn_delta = timedelta(days_per_turn) def advance_date(self): if self._turn_delta is None: self._date = datetime.now() return self._date += self._turn_delta self._turn_count += 1 def rollback_date(self, rollback_days=None): rollback_days = rollback_days or self.days_per_turn self._date -= timedelta(days=rollback_days) @property def weekday(self): day = self._date.weekday() if day == 0: return \"Monday\" elif day == 1: return \"Tuesday\" elif day == 2: return \"Wednesday\" elif day == 3: return \"Thursday\" elif day == 4: return \"Friday\" elif day == 5: return \"Saturday\" elif day == 6: return \"Sunday\" return \"What kind of calendar is this? \" @property def pretty_date(self): return self.weekday + \" \" + self._date.strftime('%d, %b %Y') @property def is_final_turn(self): if not self._turn_delta: return False if self._turn_count >= self._max_turns: return True else: return False @property def turns(self): return self._turn_count @property def date(self): return self._date @property def max_turns(self): return self._max_turns @property def week_of_month(self): # https://en.wikipedia.org/wiki/ISO_week_date#Weeks_per_month first_day = self.date.replace(day=1) day_of_month = self.date.day # adjust for sundays if (first_day.weekday() == 6): adjusted_dom = (1 + first_day.weekday()) / 7 else: adjusted_dom = day_of_month + first_day.weekday() # days may belong to a month but their week may belong to another one # weeks belong to a month if its thursday falls on it if (first_day.weekday() > 3): return int(ceil(adjusted_dom / 7.0)) - 1 else: return int(ceil(adjusted_dom / 7.0)) # in here register the word triggers # im only using keyword rules instead of sample phrases # literal strings are used as keywords # if available on locale folder vocabulary is expanded def register_core_intents(self): self.register_keyword_intent(\"advance\", required=[\"date\", \"advance\"], optionals=[], handler=self.handle_advance) self.register_keyword_intent(\"rollback\", required=[\"rollback\", \"date\"], optionals=[], handler=self.handle_rollback) self.register_keyword_intent(\"speed_decrease\", required=[\"decrease\", \"speed\"], optionals=[], handler=self.handle_speed_decrease) self.register_keyword_intent(\"speed_increase\", required=[\"increase\", \"speed\"], optionals=[], handler=self.handle_speed_increase) self.register_keyword_intent(\"days_per_turn\", required=[\"turns\", \"day\"], optionals=[\"question\"], handler=self.handle_days_per_turn) self.register_keyword_intent(\"turns_max\", required=[\"turns\", \"total\"], optionals=[\"question\"], handler=self.handle_turns_max) self.register_keyword_intent(\"turns_past\", required=[\"turns\", \"past\"], optionals=[\"question\"], handler=self.handle_turns_past) self.register_keyword_intent(\"turns_current\", required=[\"turns\", \"current\"], optionals=[\"question\"], handler=self.handle_turns_current) self.register_keyword_intent(\"turns_left\", required=[\"turns\", \"remaining\"], optionals=[\"question\"], handler=self.handle_turns_left) self.register_keyword_intent(\"next_turn\", required=[\"next\", \"turn\"], optionals=[], handler=self.handle_next_turn) self.register_keyword_intent(\"ask_day\", required=[\"day\"], optionals=[\"question\"], handler=self.handle_day) self.register_keyword_intent(\"ask_week\", required=[\"week\"], optionals=[\"question\"], handler=self.handle_week) self.register_keyword_intent(\"ask_weekday\", required=[\"weekday\"], optionals=[\"question\"], handler=self.handle_weekday) self.register_keyword_intent(\"ask_month\", required=[\"month\"], optionals=[\"question\"], handler=self.handle_month) self.register_keyword_intent(\"ask_year\", required=[\"year\"], optionals=[\"question\"], handler=self.handle_year) self.register_keyword_intent(\"ask_date\", required=[\"date\"], optionals=[\"question\"], handler=self.handle_date) # handlers for each natural language questions def handle_date(self, intent): return self.pretty_date def handle_week(self, intent): # TODO util to pronounce cardinals return \"it is the \" + str(self.week_of_month) + \" week of the month\" def handle_weekday(self, intent): return self.weekday def handle_month(self, intent): return str(self.date.month) def handle_day(self, intent): return str(self.date.day) def handle_year(self, intent): return \"it is the year \" + str(self.date.year) def handle_days_per_turn(self, intent): return str(self._turn_delta) + \" days per turn\" def handle_turns_left(self, intent): return \"you have \" + str(self.max_turns - self.turns) + \" left\" def handle_turns_max(self, intent): return \"maximum number of turns is \" + str(self.max_turns) def handle_turns_current(self, intent): return \"currently in turn\" + str(self.turns) def handle_turns_past(self, intent): return str(self.turns - 1) + \" passed\" def handle_next_turn(self, intent): self.advance_date() return \"now in turn\" + str(self.turns) def handle_advance(self, intent): self.advance_date() return \"advanced date by \" + str(self._turn_delta) + \" days\" def handle_rollback(self, intent): number = self.extract_number(intent[\"utterance\"]) self.rollback_date(number) return \"rolled back date by \" + str(number) + \" days\" def handle_speed_decrease(self, intent): number = self.extract_number(intent[\"utterance\"]) number = number or 1 self.change_speed(self._turn_delta - number) return \"decreased speed by \" + str(number) + \" days\" def handle_speed_increase(self, intent): number = self.extract_number(intent[\"utterance\"]) number = number or 1 self.change_speed(self._turn_delta - number) return \"increased speed by \" + str(number) + \" days\" you can interact with it now if __name__ == \"__main__\": construct = Calendar() print(construct.parse_command(\"current date\")) print(construct.parse_command(\"what day\")) print(construct.parse_command(\"what month\")) print(construct.parse_command(\"what weekday\")) print(construct.parse_command(\"total turns\")) # Saturday 13, Oct 2018 # 13 # 10 # Saturday # maximum number of turns is 20","title":"Usage"},{"location":"tnalagmes.constructs/","text":"Module tnalagmes.constructs LOG Custom logger class that acts like logging.Logger The logger name is automatically generated by the module of the caller Usage: >>> LOG.debug('My message: %s', debug_str) 13:12:43.673 - : :1 - DEBUG - My message: hi >>> LOG('custom_name').debug('Another message') 13:13:10.462 - custom_name - DEBUG - Another message create_logger def create_logger(name) debug def debug(*args, **kwargs) Log 'msg % args' with severity 'DEBUG'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=1) error def error(*args, **kwargs) Log 'msg % args' with severity 'ERROR'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.error(\"Houston, we have a %s\", \"major problem\", exc_info=1) exception def exception(*args, **kwargs) Convenience method for logging an ERROR with exception information. info def info(*args, **kwargs) Log 'msg % args' with severity 'INFO'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1) init def init() warning def warning(*args, **kwargs) Log 'msg % args' with severity 'WARNING'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=1) SequenceMatcher SequenceMatcher is a flexible class for comparing pairs of sequences of any type, so long as the sequence elements are hashable. The basic algorithm predates, and is a little fancier than, an algorithm published in the late 1980's by Ratcliff and Obershelp under the hyperbolic name \"gestalt pattern matching\". The basic idea is to find the longest contiguous matching subsequence that contains no \"junk\" elements (R-O doesn't address junk). The same idea is then applied recursively to the pieces of the sequences to the left and to the right of the matching subsequence. This does not yield minimal edit sequences, but does tend to yield matches that \"look right\" to people. SequenceMatcher tries to compute a \"human-friendly diff\" between two sequences. Unlike e.g. UNIX(tm) diff, the fundamental notion is the longest contiguous & junk-free matching subsequence. That's what catches peoples' eyes. The Windows(tm) windiff has another interesting notion, pairing up elements that appear uniquely in each sequence. That, and the method here, appear to yield more intuitive difference reports than does diff. This method appears to be the least vulnerable to synching up on blocks of \"junk lines\", though (like blank lines in ordinary text files, or maybe \" \" lines in HTML files). That may be because this is the only method of the 3 that has a concept of \"junk\" . Example, comparing two strings, and considering blanks to be \"junk\": s = SequenceMatcher(lambda x: x == \" \", ... \"private Thread currentThread;\", ... \"private volatile Thread currentThread;\") .ratio() returns a float in [0, 1], measuring the \"similarity\" of the sequences. As a rule of thumb, a .ratio() value over 0.6 means the sequences are close matches: print(round(s.ratio(), 3)) 0.866 If you're only interested in where the sequences match, .get_matching_blocks() is handy: for block in s.get_matching_blocks(): ... print(\"a[%d] and b[%d] match for %d elements\" % block) a[0] and b[0] match for 8 elements a[8] and b[17] match for 21 elements a[29] and b[38] match for 0 elements Note that the last tuple returned by .get_matching_blocks() is always a dummy, (len(a), len(b), 0), and this is the only case in which the last tuple element (number of elements matched) is 0. If you want to know how to change the first sequence into the second, use .get_opcodes(): for opcode in s.get_opcodes(): ... print(\"%6s a[%d:%d] b[%d:%d]\" % opcode) equal a[0:8] b[0:8] insert a[8:8] b[8:17] equal a[8:29] b[17:38] See the Differ class for a fancy human-friendly file differencer, which uses SequenceMatcher both to compare sequences of lines, and to compare sequences of characters within similar (near-matching) lines. See also function get_close_matches() in this module, which shows how simple code building on SequenceMatcher can be used to do useful work. Timing: Basic R-O is cubic time worst case and quadratic time expected case. SequenceMatcher is quadratic time for the worst case and has expected-case behavior dependent in a complicated way on how many elements the sequences have in common; best case time is linear. Methods: init (isjunk=None, a='', b='') Construct a SequenceMatcher. set_seqs(a, b) Set the two sequences to be compared. set_seq1(a) Set the first sequence to be compared. set_seq2(b) Set the second sequence to be compared. find_longest_match(alo, ahi, blo, bhi) Find longest matching block in a[alo:ahi] and b[blo:bhi]. get_matching_blocks() Return list of triples describing matching subsequences. get_opcodes() Return list of 5-tuples describing how to turn a into b. ratio() Return a measure of the sequences' similarity (float in [0,1]). quick_ratio() Return an upper bound on .ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. TNaLaGmesConstruct None datetime datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. relativedelta The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect.","title":"constructs"},{"location":"tnalagmes.constructs/#module-tnalagmesconstructs","text":"","title":"Module tnalagmes.constructs"},{"location":"tnalagmes.constructs/#log","text":"Custom logger class that acts like logging.Logger The logger name is automatically generated by the module of the caller Usage: >>> LOG.debug('My message: %s', debug_str) 13:12:43.673 - : :1 - DEBUG - My message: hi >>> LOG('custom_name').debug('Another message') 13:13:10.462 - custom_name - DEBUG - Another message","title":"LOG"},{"location":"tnalagmes.constructs/#create95logger","text":"def create_logger(name)","title":"create_logger"},{"location":"tnalagmes.constructs/#debug","text":"def debug(*args, **kwargs) Log 'msg % args' with severity 'DEBUG'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=1)","title":"debug"},{"location":"tnalagmes.constructs/#error","text":"def error(*args, **kwargs) Log 'msg % args' with severity 'ERROR'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.error(\"Houston, we have a %s\", \"major problem\", exc_info=1)","title":"error"},{"location":"tnalagmes.constructs/#exception","text":"def exception(*args, **kwargs) Convenience method for logging an ERROR with exception information.","title":"exception"},{"location":"tnalagmes.constructs/#info","text":"def info(*args, **kwargs) Log 'msg % args' with severity 'INFO'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1)","title":"info"},{"location":"tnalagmes.constructs/#init","text":"def init()","title":"init"},{"location":"tnalagmes.constructs/#warning","text":"def warning(*args, **kwargs) Log 'msg % args' with severity 'WARNING'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=1)","title":"warning"},{"location":"tnalagmes.constructs/#sequencematcher","text":"SequenceMatcher is a flexible class for comparing pairs of sequences of any type, so long as the sequence elements are hashable. The basic algorithm predates, and is a little fancier than, an algorithm published in the late 1980's by Ratcliff and Obershelp under the hyperbolic name \"gestalt pattern matching\". The basic idea is to find the longest contiguous matching subsequence that contains no \"junk\" elements (R-O doesn't address junk). The same idea is then applied recursively to the pieces of the sequences to the left and to the right of the matching subsequence. This does not yield minimal edit sequences, but does tend to yield matches that \"look right\" to people. SequenceMatcher tries to compute a \"human-friendly diff\" between two sequences. Unlike e.g. UNIX(tm) diff, the fundamental notion is the longest contiguous & junk-free matching subsequence. That's what catches peoples' eyes. The Windows(tm) windiff has another interesting notion, pairing up elements that appear uniquely in each sequence. That, and the method here, appear to yield more intuitive difference reports than does diff. This method appears to be the least vulnerable to synching up on blocks of \"junk lines\", though (like blank lines in ordinary text files, or maybe \" \" lines in HTML files). That may be because this is the only method of the 3 that has a concept of \"junk\" . Example, comparing two strings, and considering blanks to be \"junk\": s = SequenceMatcher(lambda x: x == \" \", ... \"private Thread currentThread;\", ... \"private volatile Thread currentThread;\") .ratio() returns a float in [0, 1], measuring the \"similarity\" of the sequences. As a rule of thumb, a .ratio() value over 0.6 means the sequences are close matches: print(round(s.ratio(), 3)) 0.866 If you're only interested in where the sequences match, .get_matching_blocks() is handy: for block in s.get_matching_blocks(): ... print(\"a[%d] and b[%d] match for %d elements\" % block) a[0] and b[0] match for 8 elements a[8] and b[17] match for 21 elements a[29] and b[38] match for 0 elements Note that the last tuple returned by .get_matching_blocks() is always a dummy, (len(a), len(b), 0), and this is the only case in which the last tuple element (number of elements matched) is 0. If you want to know how to change the first sequence into the second, use .get_opcodes(): for opcode in s.get_opcodes(): ... print(\"%6s a[%d:%d] b[%d:%d]\" % opcode) equal a[0:8] b[0:8] insert a[8:8] b[8:17] equal a[8:29] b[17:38] See the Differ class for a fancy human-friendly file differencer, which uses SequenceMatcher both to compare sequences of lines, and to compare sequences of characters within similar (near-matching) lines. See also function get_close_matches() in this module, which shows how simple code building on SequenceMatcher can be used to do useful work. Timing: Basic R-O is cubic time worst case and quadratic time expected case. SequenceMatcher is quadratic time for the worst case and has expected-case behavior dependent in a complicated way on how many elements the sequences have in common; best case time is linear. Methods: init (isjunk=None, a='', b='') Construct a SequenceMatcher. set_seqs(a, b) Set the two sequences to be compared. set_seq1(a) Set the first sequence to be compared. set_seq2(b) Set the second sequence to be compared. find_longest_match(alo, ahi, blo, bhi) Find longest matching block in a[alo:ahi] and b[blo:bhi]. get_matching_blocks() Return list of triples describing matching subsequences. get_opcodes() Return list of 5-tuples describing how to turn a into b. ratio() Return a measure of the sequences' similarity (float in [0,1]). quick_ratio() Return an upper bound on .ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly.","title":"SequenceMatcher"},{"location":"tnalagmes.constructs/#tnalagmesconstruct","text":"None","title":"TNaLaGmesConstruct"},{"location":"tnalagmes.constructs/#datetime","text":"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.","title":"datetime"},{"location":"tnalagmes.constructs/#relativedelta","text":"The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect.","title":"relativedelta"},{"location":"tnalagmes.data.oregon_trail_data/","text":"Module tnalagmes.data.oregon_trail_data","title":"oregon_trail_data"},{"location":"tnalagmes.data.oregon_trail_data/#module-tnalagmesdataoregon_trail_data","text":"","title":"Module tnalagmes.data.oregon_trail_data"},{"location":"tnalagmes.data.template_data/","text":"Module tnalagmes.data.template_data","title":"template_data"},{"location":"tnalagmes.data.template_data/#module-tnalagmesdatatemplate_data","text":"","title":"Module tnalagmes.data.template_data"},{"location":"tnalagmes.data.zombie_survival_data/","text":"Module tnalagmes.data.zombie_survival_data","title":"zombie_survival_data"},{"location":"tnalagmes.data.zombie_survival_data/#module-tnalagmesdatazombie_survival_data","text":"","title":"Module tnalagmes.data.zombie_survival_data"},{"location":"tnalagmes.engines.intentworld/","text":"Module tnalagmes.engines.intentworld Calendar Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\" InventoryItem what are you what can you do how much are you worth ProgressTracker \"total distance\" \"current mileage\" \"add mileage\" \"subtract mileage\" \"are you completed?\" \"current difficulty TNaLaGmesConstruct None TNaLaGmesEngine None export_game_data def export_game_data(path=None) get_entity def get_entity(text) import_game_data def import_game_data(path=None)","title":"intentworld"},{"location":"tnalagmes.engines.intentworld/#module-tnalagmesenginesintentworld","text":"","title":"Module tnalagmes.engines.intentworld"},{"location":"tnalagmes.engines.intentworld/#calendar","text":"Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\"","title":"Calendar"},{"location":"tnalagmes.engines.intentworld/#inventoryitem","text":"what are you what can you do how much are you worth","title":"InventoryItem"},{"location":"tnalagmes.engines.intentworld/#progresstracker","text":"\"total distance\" \"current mileage\" \"add mileage\" \"subtract mileage\" \"are you completed?\" \"current difficulty","title":"ProgressTracker"},{"location":"tnalagmes.engines.intentworld/#tnalagmesconstruct","text":"None","title":"TNaLaGmesConstruct"},{"location":"tnalagmes.engines.intentworld/#tnalagmesengine","text":"None","title":"TNaLaGmesEngine"},{"location":"tnalagmes.engines.intentworld/#export95game95data","text":"def export_game_data(path=None)","title":"export_game_data"},{"location":"tnalagmes.engines.intentworld/#get95entity","text":"def get_entity(text)","title":"get_entity"},{"location":"tnalagmes.engines.intentworld/#import95game95data","text":"def import_game_data(path=None)","title":"import_game_data"},{"location":"tnalagmes.engines.oregon/","text":"Module tnalagmes.engines.oregon Calendar Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\" Inventory what do you have how much money do you have how much are you worth InventoryItem what are you what can you do how much are you worth OregonEngine so called because logic is based on oregon trail ProgressTracker \"total distance\" \"current mileage\" \"add mileage\" \"subtract mileage\" \"are you completed?\" \"current difficulty SimpleInventory what do you have how much money do you have how much are you worth get_entity def get_entity(text) TNaLaGmesConstruct None TNaLaGmesEngine None export_game_data def export_game_data(path=None) get_entity def get_entity(text) import_game_data def import_game_data(path=None) TurnState am i injured am i eating/poorly/moderately/well suffering illness","title":"oregon"},{"location":"tnalagmes.engines.oregon/#module-tnalagmesenginesoregon","text":"","title":"Module tnalagmes.engines.oregon"},{"location":"tnalagmes.engines.oregon/#calendar","text":"Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\"","title":"Calendar"},{"location":"tnalagmes.engines.oregon/#inventory","text":"what do you have how much money do you have how much are you worth","title":"Inventory"},{"location":"tnalagmes.engines.oregon/#inventoryitem","text":"what are you what can you do how much are you worth","title":"InventoryItem"},{"location":"tnalagmes.engines.oregon/#oregonengine","text":"so called because logic is based on oregon trail","title":"OregonEngine"},{"location":"tnalagmes.engines.oregon/#progresstracker","text":"\"total distance\" \"current mileage\" \"add mileage\" \"subtract mileage\" \"are you completed?\" \"current difficulty","title":"ProgressTracker"},{"location":"tnalagmes.engines.oregon/#simpleinventory","text":"what do you have how much money do you have how much are you worth","title":"SimpleInventory"},{"location":"tnalagmes.engines.oregon/#get95entity","text":"def get_entity(text)","title":"get_entity"},{"location":"tnalagmes.engines.oregon/#tnalagmesconstruct","text":"None","title":"TNaLaGmesConstruct"},{"location":"tnalagmes.engines.oregon/#tnalagmesengine","text":"None","title":"TNaLaGmesEngine"},{"location":"tnalagmes.engines.oregon/#export95game95data","text":"def export_game_data(path=None)","title":"export_game_data"},{"location":"tnalagmes.engines.oregon/#get95entity_1","text":"def get_entity(text)","title":"get_entity"},{"location":"tnalagmes.engines.oregon/#import95game95data","text":"def import_game_data(path=None)","title":"import_game_data"},{"location":"tnalagmes.engines.oregon/#turnstate","text":"am i injured am i eating/poorly/moderately/well suffering illness","title":"TurnState"},{"location":"tnalagmes.engines.oregon75/","text":"Module tnalagmes.engines.oregon75 Event None Oregon75Engine so called because logic is ported from 1975 basic version of oregon trail SimpleInventory what do you have how much money do you have how much are you worth get_entity def get_entity(text) TNaLaGmesEngine None export_game_data def export_game_data(path=None) get_entity def get_entity(text) import_game_data def import_game_data(path=None) TurnState am i injured am i eating/poorly/moderately/well suffering illness","title":"oregon75"},{"location":"tnalagmes.engines.oregon75/#module-tnalagmesenginesoregon75","text":"","title":"Module tnalagmes.engines.oregon75"},{"location":"tnalagmes.engines.oregon75/#event","text":"None","title":"Event"},{"location":"tnalagmes.engines.oregon75/#oregon75engine","text":"so called because logic is ported from 1975 basic version of oregon trail","title":"Oregon75Engine"},{"location":"tnalagmes.engines.oregon75/#simpleinventory","text":"what do you have how much money do you have how much are you worth","title":"SimpleInventory"},{"location":"tnalagmes.engines.oregon75/#get95entity","text":"def get_entity(text)","title":"get_entity"},{"location":"tnalagmes.engines.oregon75/#tnalagmesengine","text":"None","title":"TNaLaGmesEngine"},{"location":"tnalagmes.engines.oregon75/#export95game95data","text":"def export_game_data(path=None)","title":"export_game_data"},{"location":"tnalagmes.engines.oregon75/#get95entity_1","text":"def get_entity(text)","title":"get_entity"},{"location":"tnalagmes.engines.oregon75/#import95game95data","text":"def import_game_data(path=None)","title":"import_game_data"},{"location":"tnalagmes.engines.oregon75/#turnstate","text":"am i injured am i eating/poorly/moderately/well suffering illness","title":"TurnState"},{"location":"tnalagmes.engines.oregon78/","text":"Module tnalagmes.engines.oregon78 Oregon75Engine so called because logic is ported from 1975 basic version of oregon trail Oregon78Engine so called because logic is ported from 1978 basic version of oregon trail","title":"oregon78"},{"location":"tnalagmes.engines.oregon78/#module-tnalagmesenginesoregon78","text":"","title":"Module tnalagmes.engines.oregon78"},{"location":"tnalagmes.engines.oregon78/#oregon75engine","text":"so called because logic is ported from 1975 basic version of oregon trail","title":"Oregon75Engine"},{"location":"tnalagmes.engines.oregon78/#oregon78engine","text":"so called because logic is ported from 1978 basic version of oregon trail","title":"Oregon78Engine"},{"location":"tnalagmes.engines.textadventurer/","text":"Module tnalagmes.engines.textadventurer Calendar Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\" InventoryItem what are you what can you do how much are you worth ProgressTracker \"total distance\" \"current mileage\" \"add mileage\" \"subtract mileage\" \"are you completed?\" \"current difficulty TNaLaGmesConstruct None TNaLaGmesEngine None export_game_data def export_game_data(path=None) get_entity def get_entity(text) import_game_data def import_game_data(path=None)","title":"textadventurer"},{"location":"tnalagmes.engines.textadventurer/#module-tnalagmesenginestextadventurer","text":"","title":"Module tnalagmes.engines.textadventurer"},{"location":"tnalagmes.engines.textadventurer/#calendar","text":"Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\"","title":"Calendar"},{"location":"tnalagmes.engines.textadventurer/#inventoryitem","text":"what are you what can you do how much are you worth","title":"InventoryItem"},{"location":"tnalagmes.engines.textadventurer/#progresstracker","text":"\"total distance\" \"current mileage\" \"add mileage\" \"subtract mileage\" \"are you completed?\" \"current difficulty","title":"ProgressTracker"},{"location":"tnalagmes.engines.textadventurer/#tnalagmesconstruct","text":"None","title":"TNaLaGmesConstruct"},{"location":"tnalagmes.engines.textadventurer/#tnalagmesengine","text":"None","title":"TNaLaGmesEngine"},{"location":"tnalagmes.engines.textadventurer/#export95game95data","text":"def export_game_data(path=None)","title":"export_game_data"},{"location":"tnalagmes.engines.textadventurer/#get95entity","text":"def get_entity(text)","title":"get_entity"},{"location":"tnalagmes.engines.textadventurer/#import95game95data","text":"def import_game_data(path=None)","title":"import_game_data"},{"location":"tnalagmes.engines.textwarrior/","text":"Module tnalagmes.engines.textwarrior Calendar Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\" InventoryItem what are you what can you do how much are you worth ProgressTracker \"total distance\" \"current mileage\" \"add mileage\" \"subtract mileage\" \"are you completed?\" \"current difficulty TNaLaGmesConstruct None TNaLaGmesEngine None export_game_data def export_game_data(path=None) get_entity def get_entity(text) import_game_data def import_game_data(path=None)","title":"textwarrior"},{"location":"tnalagmes.engines.textwarrior/#module-tnalagmesenginestextwarrior","text":"","title":"Module tnalagmes.engines.textwarrior"},{"location":"tnalagmes.engines.textwarrior/#calendar","text":"Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\"","title":"Calendar"},{"location":"tnalagmes.engines.textwarrior/#inventoryitem","text":"what are you what can you do how much are you worth","title":"InventoryItem"},{"location":"tnalagmes.engines.textwarrior/#progresstracker","text":"\"total distance\" \"current mileage\" \"add mileage\" \"subtract mileage\" \"are you completed?\" \"current difficulty","title":"ProgressTracker"},{"location":"tnalagmes.engines.textwarrior/#tnalagmesconstruct","text":"None","title":"TNaLaGmesConstruct"},{"location":"tnalagmes.engines.textwarrior/#tnalagmesengine","text":"None","title":"TNaLaGmesEngine"},{"location":"tnalagmes.engines.textwarrior/#export95game95data","text":"def export_game_data(path=None)","title":"export_game_data"},{"location":"tnalagmes.engines.textwarrior/#get95entity","text":"def get_entity(text)","title":"get_entity"},{"location":"tnalagmes.engines.textwarrior/#import95game95data","text":"def import_game_data(path=None)","title":"import_game_data"},{"location":"tnalagmes.games.dummy/","text":"Module tnalagmes.games.dummy Oregon75Engine so called because logic is ported from 1975 basic version of oregon trail TemplateGame so called because logic is ported from 1975 basic version of oregon trail","title":"dummy"},{"location":"tnalagmes.games.dummy/#module-tnalagmesgamesdummy","text":"","title":"Module tnalagmes.games.dummy"},{"location":"tnalagmes.games.dummy/#oregon75engine","text":"so called because logic is ported from 1975 basic version of oregon trail","title":"Oregon75Engine"},{"location":"tnalagmes.games.dummy/#templategame","text":"so called because logic is ported from 1975 basic version of oregon trail","title":"TemplateGame"},{"location":"tnalagmes.games.oregon_trail/","text":"Module tnalagmes.games.oregon_trail Calendar Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\" Oregon75Engine so called because logic is ported from 1975 basic version of oregon trail OregonTrail so called because logic is ported from 1975 basic version of oregon trail date date(year, month, day) --> date object","title":"oregon_trail"},{"location":"tnalagmes.games.oregon_trail/#module-tnalagmesgamesoregon_trail","text":"","title":"Module tnalagmes.games.oregon_trail"},{"location":"tnalagmes.games.oregon_trail/#calendar","text":"Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\"","title":"Calendar"},{"location":"tnalagmes.games.oregon_trail/#oregon75engine","text":"so called because logic is ported from 1975 basic version of oregon trail","title":"Oregon75Engine"},{"location":"tnalagmes.games.oregon_trail/#oregontrail","text":"so called because logic is ported from 1975 basic version of oregon trail","title":"OregonTrail"},{"location":"tnalagmes.games.oregon_trail/#date","text":"date(year, month, day) --> date object","title":"date"},{"location":"tnalagmes.games.zombie/","text":"Module tnalagmes.games.zombie Calendar Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\" Oregon75Engine so called because logic is ported from 1975 basic version of oregon trail SimpleInventory what do you have how much money do you have how much are you worth get_entity def get_entity(text) ZVirus so called because logic is ported from 1975 basic version of oregon trail","title":"zombie"},{"location":"tnalagmes.games.zombie/#module-tnalagmesgameszombie","text":"","title":"Module tnalagmes.games.zombie"},{"location":"tnalagmes.games.zombie/#calendar","text":"Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\"","title":"Calendar"},{"location":"tnalagmes.games.zombie/#oregon75engine","text":"so called because logic is ported from 1975 basic version of oregon trail","title":"Oregon75Engine"},{"location":"tnalagmes.games.zombie/#simpleinventory","text":"what do you have how much money do you have how much are you worth","title":"SimpleInventory"},{"location":"tnalagmes.games.zombie/#get95entity","text":"def get_entity(text)","title":"get_entity"},{"location":"tnalagmes.games.zombie/#zvirus","text":"so called because logic is ported from 1975 basic version of oregon trail","title":"ZVirus"},{"location":"tnalagmes.lang.format_common/","text":"Module tnalagmes.lang.format_common convert_to_mixed_fraction def convert_to_mixed_fraction(number, denominators) Convert floats to components of a mixed fraction representation Returns the closest fractional representation using the provided denominators. For example, 4.500002 would become the whole number 4, the numerator 1 and the denominator 2 Args: number (float): number for convert denominators (iter of ints): denominators to use, default [1 .. 20] Returns: whole, numerator, denominator (int): Integers of the mixed fraction","title":"format_common"},{"location":"tnalagmes.lang.format_common/#module-tnalagmeslangformat_common","text":"","title":"Module tnalagmes.lang.format_common"},{"location":"tnalagmes.lang.format_common/#convert95to95mixed95fraction","text":"def convert_to_mixed_fraction(number, denominators) Convert floats to components of a mixed fraction representation Returns the closest fractional representation using the provided denominators. For example, 4.500002 would become the whole number 4, the numerator 1 and the denominator 2 Args: number (float): number for convert denominators (iter of ints): denominators to use, default [1 .. 20] Returns: whole, numerator, denominator (int): Integers of the mixed fraction","title":"convert_to_mixed_fraction"},{"location":"tnalagmes.lang.format_de/","text":"Module tnalagmes.lang.format_de nice_number_de def nice_number_de(number, speech, denominators) German helper for nice_number This function formats a float to human understandable functions. Like 4.5 becomes \"4 einhalb\" for speech and \"4 1/2\" for text Args: number (int or float): the float to format speech (bool): format for speech (True) or display (False) denominators (iter of ints): denominators to use, default [1 .. 20] Returns: (str): The formatted string. nice_ordinal_de def nice_ordinal_de(text) nice_response_de def nice_response_de(text) nice_time_de def nice_time_de(dt, speech=True, use_24hour=False, use_ampm=False) Format a time to a comfortable human format For example, generate 'five thirty' for speech or '5:30' for text display. Args: dt (datetime): date to format (assumes already in local timezone) speech (bool): format for speech (default/True) or display (False)=Fal use_24hour (bool): output in 24-hour/military or 12-hour format use_ampm (bool): include the am/pm for 12-hour format Returns: (str): The formatted time string pronounce_number_de def pronounce_number_de(num, places=2) Convert a number to its spoken equivalent For example, '5.2' would return 'five point two' Args: num(float or int): the number to pronounce (set limit below) places(int): maximum decimal places to speak Returns: (str): The pronounced number pronounce_ordinal_de def pronounce_ordinal_de(num)","title":"format_de"},{"location":"tnalagmes.lang.format_de/#module-tnalagmeslangformat_de","text":"","title":"Module tnalagmes.lang.format_de"},{"location":"tnalagmes.lang.format_de/#nice95number95de","text":"def nice_number_de(number, speech, denominators) German helper for nice_number This function formats a float to human understandable functions. Like 4.5 becomes \"4 einhalb\" for speech and \"4 1/2\" for text Args: number (int or float): the float to format speech (bool): format for speech (True) or display (False) denominators (iter of ints): denominators to use, default [1 .. 20] Returns: (str): The formatted string.","title":"nice_number_de"},{"location":"tnalagmes.lang.format_de/#nice95ordinal95de","text":"def nice_ordinal_de(text)","title":"nice_ordinal_de"},{"location":"tnalagmes.lang.format_de/#nice95response95de","text":"def nice_response_de(text)","title":"nice_response_de"},{"location":"tnalagmes.lang.format_de/#nice95time95de","text":"def nice_time_de(dt, speech=True, use_24hour=False, use_ampm=False) Format a time to a comfortable human format For example, generate 'five thirty' for speech or '5:30' for text display. Args: dt (datetime): date to format (assumes already in local timezone) speech (bool): format for speech (default/True) or display (False)=Fal use_24hour (bool): output in 24-hour/military or 12-hour format use_ampm (bool): include the am/pm for 12-hour format Returns: (str): The formatted time string","title":"nice_time_de"},{"location":"tnalagmes.lang.format_de/#pronounce95number95de","text":"def pronounce_number_de(num, places=2) Convert a number to its spoken equivalent For example, '5.2' would return 'five point two' Args: num(float or int): the number to pronounce (set limit below) places(int): maximum decimal places to speak Returns: (str): The pronounced number","title":"pronounce_number_de"},{"location":"tnalagmes.lang.format_de/#pronounce95ordinal95de","text":"def pronounce_ordinal_de(num)","title":"pronounce_ordinal_de"},{"location":"tnalagmes.lang.format_en/","text":"Module tnalagmes.lang.format_en datetime datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. timedelta Difference between two datetime values. nice_number_en def nice_number_en(number, speech, denominators) English helper for nice_number This function formats a float to human understandable functions. Like 4.5 becomes \"4 and a half\" for speech and \"4 1/2\" for text Args: number (int or float): the float to format speech (bool): format for speech (True) or display (False) denominators (iter of ints): denominators to use, default [1 .. 20] Returns: (str): The formatted string. nice_time_delta_en def nice_time_delta_en(time_delta, anchor=None) Get a timedelta or datetime object or a int() Epoch timestamp and return a pretty string like 'an hour ago', 'Yesterday', '3 months ago', 'just now', etc nice_time_en def nice_time_en(dt, speech=True, use_24hour=False, use_ampm=False) Format a time to a comfortable human format For example, generate 'five thirty' for speech or '5:30' for text display. Args: dt (datetime): date to format (assumes already in local timezone) speech (bool): format for speech (default/True) or display (False)=Fal use_24hour (bool): output in 24-hour/military or 12-hour format use_ampm (bool): include the am/pm for 12-hour format Returns: (str): The formatted time string pronounce_number_en def pronounce_number_en(num, places=2, short_scale=True, scientific=False) Convert a number to it's spoken equivalent For example, '5.2' would return 'five point two' Args: num(float or int): the number to pronounce (under 100) places(int): maximum decimal places to speak short_scale (bool) : use short (True) or long scale (False) https://en.wikipedia.org/wiki/Names_of_large_numbers scientific (bool): pronounce in scientific notation Returns: (str): The pronounced number","title":"format_en"},{"location":"tnalagmes.lang.format_en/#module-tnalagmeslangformat_en","text":"","title":"Module tnalagmes.lang.format_en"},{"location":"tnalagmes.lang.format_en/#datetime","text":"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.","title":"datetime"},{"location":"tnalagmes.lang.format_en/#timedelta","text":"Difference between two datetime values.","title":"timedelta"},{"location":"tnalagmes.lang.format_en/#nice95number95en","text":"def nice_number_en(number, speech, denominators) English helper for nice_number This function formats a float to human understandable functions. Like 4.5 becomes \"4 and a half\" for speech and \"4 1/2\" for text Args: number (int or float): the float to format speech (bool): format for speech (True) or display (False) denominators (iter of ints): denominators to use, default [1 .. 20] Returns: (str): The formatted string.","title":"nice_number_en"},{"location":"tnalagmes.lang.format_en/#nice95time95delta95en","text":"def nice_time_delta_en(time_delta, anchor=None) Get a timedelta or datetime object or a int() Epoch timestamp and return a pretty string like 'an hour ago', 'Yesterday', '3 months ago', 'just now', etc","title":"nice_time_delta_en"},{"location":"tnalagmes.lang.format_en/#nice95time95en","text":"def nice_time_en(dt, speech=True, use_24hour=False, use_ampm=False) Format a time to a comfortable human format For example, generate 'five thirty' for speech or '5:30' for text display. Args: dt (datetime): date to format (assumes already in local timezone) speech (bool): format for speech (default/True) or display (False)=Fal use_24hour (bool): output in 24-hour/military or 12-hour format use_ampm (bool): include the am/pm for 12-hour format Returns: (str): The formatted time string","title":"nice_time_en"},{"location":"tnalagmes.lang.format_en/#pronounce95number95en","text":"def pronounce_number_en(num, places=2, short_scale=True, scientific=False) Convert a number to it's spoken equivalent For example, '5.2' would return 'five point two' Args: num(float or int): the number to pronounce (under 100) places(int): maximum decimal places to speak short_scale (bool) : use short (True) or long scale (False) https://en.wikipedia.org/wiki/Names_of_large_numbers scientific (bool): pronounce in scientific notation Returns: (str): The pronounced number","title":"pronounce_number_en"},{"location":"tnalagmes.lang.format_fr/","text":"Module tnalagmes.lang.format_fr Format functions for french (fr) nice_number_fr def nice_number_fr(number, speech, denominators) French helper for nice_number This function formats a float to human understandable functions. Like 4.5 becomes \"4 et demi\" for speech and \"4 1/2\" for text Args: number (int or float): the float to format speech (bool): format for speech (True) or display (False) denominators (iter of ints): denominators to use, default [1 .. 20] Returns: (str): The formatted string. nice_time_fr def nice_time_fr(dt, speech=True, use_24hour=False, use_ampm=False) Format a time to a comfortable human format For example, generate 'cinq heures trente' for speech or '5:30' for text display. Args: dt (datetime): date to format (assumes already in local timezone) speech (bool): format for speech (default/True) or display (False)=Fal use_24hour (bool): output in 24-hour/military or 12-hour format use_ampm (bool): include the am/pm for 12-hour format Returns: (str): The formatted time string pronounce_number_fr def pronounce_number_fr(num, places=2) Convert a number to it's spoken equivalent For example, '5.2' would return 'cinq virgule deux' Args: num(float or int): the number to pronounce (under 100) places(int): maximum decimal places to speak Returns: (str): The pronounced number","title":"format_fr"},{"location":"tnalagmes.lang.format_fr/#module-tnalagmeslangformat_fr","text":"Format functions for french (fr)","title":"Module tnalagmes.lang.format_fr"},{"location":"tnalagmes.lang.format_fr/#nice95number95fr","text":"def nice_number_fr(number, speech, denominators) French helper for nice_number This function formats a float to human understandable functions. Like 4.5 becomes \"4 et demi\" for speech and \"4 1/2\" for text Args: number (int or float): the float to format speech (bool): format for speech (True) or display (False) denominators (iter of ints): denominators to use, default [1 .. 20] Returns: (str): The formatted string.","title":"nice_number_fr"},{"location":"tnalagmes.lang.format_fr/#nice95time95fr","text":"def nice_time_fr(dt, speech=True, use_24hour=False, use_ampm=False) Format a time to a comfortable human format For example, generate 'cinq heures trente' for speech or '5:30' for text display. Args: dt (datetime): date to format (assumes already in local timezone) speech (bool): format for speech (default/True) or display (False)=Fal use_24hour (bool): output in 24-hour/military or 12-hour format use_ampm (bool): include the am/pm for 12-hour format Returns: (str): The formatted time string","title":"nice_time_fr"},{"location":"tnalagmes.lang.format_fr/#pronounce95number95fr","text":"def pronounce_number_fr(num, places=2) Convert a number to it's spoken equivalent For example, '5.2' would return 'cinq virgule deux' Args: num(float or int): the number to pronounce (under 100) places(int): maximum decimal places to speak Returns: (str): The pronounced number","title":"pronounce_number_fr"},{"location":"tnalagmes.lang.format_it/","text":"Module tnalagmes.lang.format_it nice_number_it def nice_number_it(number, speech, denominators) Italian helper for nice_number This function formats a float to human understandable functions. Like 4.5 becomes \"4 e un mezz\" for speech and \"4 1/2\" for text Args: number (int or float): the float to format speech (bool): format for speech (True) or display (False) denominators (iter of ints): denominators to use, default [1 .. 20] Returns: (str): The formatted string. nice_time_it def nice_time_it(dt, speech=True, use_24hour=False, use_ampm=False) Format a time to a comfortable human format adapted to italian fron en version For example, generate 'cinque e trenta' for speech or '5:30' for text display. Args: dt (datetime): date to format (assumes already in local timezone) speech (bool): format for speech (default/True) or display (False)=Fal use_24hour (bool): output in 24-hour/military or 12-hour format use_ampm (bool): include the am/pm for 12-hour format Returns: (str): The formatted time string pronounce_number_it def pronounce_number_it(num, places=2) Convert a number to it's spoken equivalent adapted to italian fron en version For example, '5.2' would return 'cinque virgola due' Args: num(float or int): the number to pronounce (under 100) places(int): maximum decimal places to speak Returns: (str): The pronounced number","title":"format_it"},{"location":"tnalagmes.lang.format_it/#module-tnalagmeslangformat_it","text":"","title":"Module tnalagmes.lang.format_it"},{"location":"tnalagmes.lang.format_it/#nice95number95it","text":"def nice_number_it(number, speech, denominators) Italian helper for nice_number This function formats a float to human understandable functions. Like 4.5 becomes \"4 e un mezz\" for speech and \"4 1/2\" for text Args: number (int or float): the float to format speech (bool): format for speech (True) or display (False) denominators (iter of ints): denominators to use, default [1 .. 20] Returns: (str): The formatted string.","title":"nice_number_it"},{"location":"tnalagmes.lang.format_it/#nice95time95it","text":"def nice_time_it(dt, speech=True, use_24hour=False, use_ampm=False) Format a time to a comfortable human format adapted to italian fron en version For example, generate 'cinque e trenta' for speech or '5:30' for text display. Args: dt (datetime): date to format (assumes already in local timezone) speech (bool): format for speech (default/True) or display (False)=Fal use_24hour (bool): output in 24-hour/military or 12-hour format use_ampm (bool): include the am/pm for 12-hour format Returns: (str): The formatted time string","title":"nice_time_it"},{"location":"tnalagmes.lang.format_it/#pronounce95number95it","text":"def pronounce_number_it(num, places=2) Convert a number to it's spoken equivalent adapted to italian fron en version For example, '5.2' would return 'cinque virgola due' Args: num(float or int): the number to pronounce (under 100) places(int): maximum decimal places to speak Returns: (str): The pronounced number","title":"pronounce_number_it"},{"location":"tnalagmes.lang.format_pt/","text":"Module tnalagmes.lang.format_pt nice_number_pt def nice_number_pt(number, speech, denominators) Portuguese helper for nice_number This function formats a float to human understandable functions. Like 4.5 becomes \"4 e meio\" for speech and \"4 1/2\" for text Args: number (int or float): the float to format speech (bool): format for speech (True) or display (False) denominators (iter of ints): denominators to use, default [1 .. 20] Returns: (str): The formatted string.","title":"format_pt"},{"location":"tnalagmes.lang.format_pt/#module-tnalagmeslangformat_pt","text":"","title":"Module tnalagmes.lang.format_pt"},{"location":"tnalagmes.lang.format_pt/#nice95number95pt","text":"def nice_number_pt(number, speech, denominators) Portuguese helper for nice_number This function formats a float to human understandable functions. Like 4.5 becomes \"4 e meio\" for speech and \"4 1/2\" for text Args: number (int or float): the float to format speech (bool): format for speech (True) or display (False) denominators (iter of ints): denominators to use, default [1 .. 20] Returns: (str): The formatted string.","title":"nice_number_pt"},{"location":"tnalagmes.lang.format_sv/","text":"Module tnalagmes.lang.format_sv nice_number_sv def nice_number_sv(number, speech, denominators) Swedish helper for nice_number This function formats a float to human understandable functions. Like 4.5 becomes \"4 och en halv\" for speech and \"4 1/2\" for text Args: number (int or float): the float to format speech (bool): format for speech (True) or display (False) denominators (iter of ints): denominators to use, default [1 .. 20] Returns: (str): The formatted string.","title":"format_sv"},{"location":"tnalagmes.lang.format_sv/#module-tnalagmeslangformat_sv","text":"","title":"Module tnalagmes.lang.format_sv"},{"location":"tnalagmes.lang.format_sv/#nice95number95sv","text":"def nice_number_sv(number, speech, denominators) Swedish helper for nice_number This function formats a float to human understandable functions. Like 4.5 becomes \"4 och en halv\" for speech and \"4 1/2\" for text Args: number (int or float): the float to format speech (bool): format for speech (True) or display (False) denominators (iter of ints): denominators to use, default [1 .. 20] Returns: (str): The formatted string.","title":"nice_number_sv"},{"location":"tnalagmes.lang.parse_common/","text":"Module tnalagmes.lang.parse_common is_numeric def is_numeric(input_str) Takes in a string and tests to see if it is a number. Args: text (str): string to test if a number Returns: (bool): True if a number, else False look_for_fractions def look_for_fractions(split_list) \" This function takes a list made by fraction & determines if a fraction. Args: split_list (list): list created by splitting on '/' Returns: (bool): False if not a fraction, otherwise True","title":"parse_common"},{"location":"tnalagmes.lang.parse_common/#module-tnalagmeslangparse_common","text":"","title":"Module tnalagmes.lang.parse_common"},{"location":"tnalagmes.lang.parse_common/#is95numeric","text":"def is_numeric(input_str) Takes in a string and tests to see if it is a number. Args: text (str): string to test if a number Returns: (bool): True if a number, else False","title":"is_numeric"},{"location":"tnalagmes.lang.parse_common/#look95for95fractions","text":"def look_for_fractions(split_list) \" This function takes a list made by fraction & determines if a fraction. Args: split_list (list): list created by splitting on '/' Returns: (bool): False if not a fraction, otherwise True","title":"look_for_fractions"},{"location":"tnalagmes.lang.parse_de/","text":"Module tnalagmes.lang.parse_de datetime datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. relativedelta The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect. extract_datetime_de def extract_datetime_de(string, currentDate) extractnumber_de def extractnumber_de(text) This function prepares the given text for parsing by making numbers consistent, getting rid of contractions, etc. Args: text (str): the string to normalize Returns: (int) or (float): The value of extracted number undefined articles cannot be suppressed in German: 'ein Pferd' means 'one horse' and 'a horse' isFractional_de def isFractional_de(input_str) This function takes the given text and checks if it is a fraction. Args: input_str (str): the string to check if fractional Returns: (bool) or (float): False if not a fraction, otherwise the fraction isOrdinal_de def isOrdinal_de(input_str) This function takes the given text and checks if it is an ordinal number. Args: input_str (str): the string to check if ordinal Returns: (bool) or (float): False if not an ordinal, otherwise the number corresponding to the ordinal ordinals for 1, 3, 7 and 8 are irregular only works for ordinals corresponding to the numbers in de_numbers normalize_de def normalize_de(text, remove_articles) German string normalization","title":"parse_de"},{"location":"tnalagmes.lang.parse_de/#module-tnalagmeslangparse_de","text":"","title":"Module tnalagmes.lang.parse_de"},{"location":"tnalagmes.lang.parse_de/#datetime","text":"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.","title":"datetime"},{"location":"tnalagmes.lang.parse_de/#relativedelta","text":"The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect.","title":"relativedelta"},{"location":"tnalagmes.lang.parse_de/#extract95datetime95de","text":"def extract_datetime_de(string, currentDate)","title":"extract_datetime_de"},{"location":"tnalagmes.lang.parse_de/#extractnumber95de","text":"def extractnumber_de(text) This function prepares the given text for parsing by making numbers consistent, getting rid of contractions, etc. Args: text (str): the string to normalize Returns: (int) or (float): The value of extracted number undefined articles cannot be suppressed in German: 'ein Pferd' means 'one horse' and 'a horse'","title":"extractnumber_de"},{"location":"tnalagmes.lang.parse_de/#isfractional95de","text":"def isFractional_de(input_str) This function takes the given text and checks if it is a fraction. Args: input_str (str): the string to check if fractional Returns: (bool) or (float): False if not a fraction, otherwise the fraction","title":"isFractional_de"},{"location":"tnalagmes.lang.parse_de/#isordinal95de","text":"def isOrdinal_de(input_str) This function takes the given text and checks if it is an ordinal number. Args: input_str (str): the string to check if ordinal Returns: (bool) or (float): False if not an ordinal, otherwise the number corresponding to the ordinal ordinals for 1, 3, 7 and 8 are irregular only works for ordinals corresponding to the numbers in de_numbers","title":"isOrdinal_de"},{"location":"tnalagmes.lang.parse_de/#normalize95de","text":"def normalize_de(text, remove_articles) German string normalization","title":"normalize_de"},{"location":"tnalagmes.lang.parse_en/","text":"Module tnalagmes.lang.parse_en datetime datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. relativedelta The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect. extract_datetime_en def extract_datetime_en(string, currentDate) Convert a human date reference into an exact datetime Convert things like \"today\" \"tomorrow afternoon\" \"next Tuesday at 4pm\" \"August 3rd\" into a datetime. If a reference date is not provided, the current local time is used. Also consumes the words used to define the date returning the remaining string. For example, the string \"what is Tuesday's weather forecast\" returns the date for the forthcoming Tuesday relative to the reference date and the remainder string \"what is weather forecast\". Args: string (str): string containing date words currentDate (datetime): A reference date/time for \"tommorrow\", etc Returns: [datetime, str]: An array containing the datetime and the remaining text not consumed in the parsing. extract_number_en def extract_number_en(text, short_scale=True, ordinals=False) This function extracts a number from a text string, handles pronunciations in long scale and short scale https://en.wikipedia.org/wiki/Names_of_large_numbers Args: text (str): the string to normalize short_scale (bool): use short scale if True, long scale if False ordinals (bool): consider ordinal numbers, third=3 instead of 1/3 Returns: (int) or (float) or False: The extracted number or False if no number was found is_fractional_en def is_fractional_en(input_str, short_scale=True) This function takes the given text and checks if it is a fraction. Args: input_str (str): the string to check if fractional short_scale (bool): use short scale if True, long scale if False Returns: (bool) or (float): False if not a fraction, otherwise the fraction normalize_en def normalize_en(text, remove_articles) English string normalization","title":"parse_en"},{"location":"tnalagmes.lang.parse_en/#module-tnalagmeslangparse_en","text":"","title":"Module tnalagmes.lang.parse_en"},{"location":"tnalagmes.lang.parse_en/#datetime","text":"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.","title":"datetime"},{"location":"tnalagmes.lang.parse_en/#relativedelta","text":"The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect.","title":"relativedelta"},{"location":"tnalagmes.lang.parse_en/#extract95datetime95en","text":"def extract_datetime_en(string, currentDate) Convert a human date reference into an exact datetime Convert things like \"today\" \"tomorrow afternoon\" \"next Tuesday at 4pm\" \"August 3rd\" into a datetime. If a reference date is not provided, the current local time is used. Also consumes the words used to define the date returning the remaining string. For example, the string \"what is Tuesday's weather forecast\" returns the date for the forthcoming Tuesday relative to the reference date and the remainder string \"what is weather forecast\". Args: string (str): string containing date words currentDate (datetime): A reference date/time for \"tommorrow\", etc Returns: [datetime, str]: An array containing the datetime and the remaining text not consumed in the parsing.","title":"extract_datetime_en"},{"location":"tnalagmes.lang.parse_en/#extract95number95en","text":"def extract_number_en(text, short_scale=True, ordinals=False) This function extracts a number from a text string, handles pronunciations in long scale and short scale https://en.wikipedia.org/wiki/Names_of_large_numbers Args: text (str): the string to normalize short_scale (bool): use short scale if True, long scale if False ordinals (bool): consider ordinal numbers, third=3 instead of 1/3 Returns: (int) or (float) or False: The extracted number or False if no number was found","title":"extract_number_en"},{"location":"tnalagmes.lang.parse_en/#is95fractional95en","text":"def is_fractional_en(input_str, short_scale=True) This function takes the given text and checks if it is a fraction. Args: input_str (str): the string to check if fractional short_scale (bool): use short scale if True, long scale if False Returns: (bool) or (float): False if not a fraction, otherwise the fraction","title":"is_fractional_en"},{"location":"tnalagmes.lang.parse_en/#normalize95en","text":"def normalize_en(text, remove_articles) English string normalization","title":"normalize_en"},{"location":"tnalagmes.lang.parse_es/","text":"Module tnalagmes.lang.parse_es Parse functions for spanish (es) TODO: numbers greater than 999999 es_parse def es_parse(words, i) normalize_es def normalize_es(text, remove_articles) Spanish string normalization","title":"parse_es"},{"location":"tnalagmes.lang.parse_es/#module-tnalagmeslangparse_es","text":"Parse functions for spanish (es) TODO: numbers greater than 999999","title":"Module tnalagmes.lang.parse_es"},{"location":"tnalagmes.lang.parse_es/#es95parse","text":"def es_parse(words, i)","title":"es_parse"},{"location":"tnalagmes.lang.parse_es/#normalize95es","text":"def normalize_es(text, remove_articles) Spanish string normalization","title":"normalize_es"},{"location":"tnalagmes.lang.parse_fr/","text":"Module tnalagmes.lang.parse_fr Parse functions for french (fr) Todo: * extractnumber_fr: ordinal numbers (\"cinqui\u00e8me\") * extractnumber_fr: numbers greater than 999 999 (\"cinq millions\") * extract_datetime_fr: \"quatri\u00e8me lundi de janvier\" * get_gender_fr datetime datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. relativedelta The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect. extract_datetime_fr def extract_datetime_fr(string, currentDate) extractnumber_fr def extractnumber_fr(text) Takes in a string and extracts a number. Args: text (str): the string to extract a number from Returns: (str): The number extracted or the original text. getOrdinal_fr def getOrdinal_fr(word) Get the ordinal number Takes in a word (string without whitespace) and extracts the ordinal number. Args: word (string): the word to extract the number from Returns: number (int) Returns None if no ordinal number was found. isFractional_fr def isFractional_fr(input_str) This function takes the given text and checks if it is a fraction. Args: input_str (str): the string to check if fractional Returns: (bool) or (float): False if not a fraction, otherwise the fraction normalize_fr def normalize_fr(text, remove_articles) French string normalization number_ordinal_fr def number_ordinal_fr(words, i) Find an ordinal number in a list of words Takes in a list of words (strings without whitespace) and extracts an ordinal number that starts at the given index. Args: words (array): the list to extract a number from i (int): the index in words where to look for the ordinal number Returns: tuple with ordinal number (str), index of next word after the number (int). Returns None if no ordinal number was found. number_parse_fr def number_parse_fr(words, i) Parses a list of words to find a number Takes in a list of words (strings without whitespace) and extracts a number that starts at the given index. Args: words (array): the list to extract a number from i (int): the index in words where to look for the number Returns: tuple with number, index of next word after the number. Returns None if no number was found.","title":"parse_fr"},{"location":"tnalagmes.lang.parse_fr/#module-tnalagmeslangparse_fr","text":"Parse functions for french (fr) Todo: * extractnumber_fr: ordinal numbers (\"cinqui\u00e8me\") * extractnumber_fr: numbers greater than 999 999 (\"cinq millions\") * extract_datetime_fr: \"quatri\u00e8me lundi de janvier\" * get_gender_fr","title":"Module tnalagmes.lang.parse_fr"},{"location":"tnalagmes.lang.parse_fr/#datetime","text":"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.","title":"datetime"},{"location":"tnalagmes.lang.parse_fr/#relativedelta","text":"The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect.","title":"relativedelta"},{"location":"tnalagmes.lang.parse_fr/#extract95datetime95fr","text":"def extract_datetime_fr(string, currentDate)","title":"extract_datetime_fr"},{"location":"tnalagmes.lang.parse_fr/#extractnumber95fr","text":"def extractnumber_fr(text) Takes in a string and extracts a number. Args: text (str): the string to extract a number from Returns: (str): The number extracted or the original text.","title":"extractnumber_fr"},{"location":"tnalagmes.lang.parse_fr/#getordinal95fr","text":"def getOrdinal_fr(word) Get the ordinal number Takes in a word (string without whitespace) and extracts the ordinal number. Args: word (string): the word to extract the number from Returns: number (int) Returns None if no ordinal number was found.","title":"getOrdinal_fr"},{"location":"tnalagmes.lang.parse_fr/#isfractional95fr","text":"def isFractional_fr(input_str) This function takes the given text and checks if it is a fraction. Args: input_str (str): the string to check if fractional Returns: (bool) or (float): False if not a fraction, otherwise the fraction","title":"isFractional_fr"},{"location":"tnalagmes.lang.parse_fr/#normalize95fr","text":"def normalize_fr(text, remove_articles) French string normalization","title":"normalize_fr"},{"location":"tnalagmes.lang.parse_fr/#number95ordinal95fr","text":"def number_ordinal_fr(words, i) Find an ordinal number in a list of words Takes in a list of words (strings without whitespace) and extracts an ordinal number that starts at the given index. Args: words (array): the list to extract a number from i (int): the index in words where to look for the ordinal number Returns: tuple with ordinal number (str), index of next word after the number (int). Returns None if no ordinal number was found.","title":"number_ordinal_fr"},{"location":"tnalagmes.lang.parse_fr/#number95parse95fr","text":"def number_parse_fr(words, i) Parses a list of words to find a number Takes in a list of words (strings without whitespace) and extracts a number that starts at the given index. Args: words (array): the list to extract a number from i (int): the index in words where to look for the number Returns: tuple with number, index of next word after the number. Returns None if no number was found.","title":"number_parse_fr"},{"location":"tnalagmes.lang.parse_it/","text":"Module tnalagmes.lang.parse_it Parse functions for Italian (IT-IT) TODO: numbers greater than 999999 TODO: it_number_parse TODO: it_pruning datetime datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. relativedelta The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect. extract_datetime_it def extract_datetime_it(string, currentDate) extractnumber_it def extractnumber_it(text) Questa funzione prepara il testo dato per l'analisi rendendo numeri testuali come interi o frazioni. In italiano non \u00e8 un modo abituale ma pu\u00f2 essere interessante per Mycroft E' la versione portoghese riadattata in italiano args: text (str): la stringa da normalizzare Ritorna: (int) o (float): il valore del numero estratto extractnumber_long_it def extractnumber_long_it(word) Questa funzione converte un numero testuale lungo es. ventisette -> 27 quarantuno -> 41 nell'equivalente valore intero args: text (str): la stringa da normalizzare Ritorna: (int) : il valore del numero estratto usando tutta la parola Falso : se la parola non \u00e8 un numero es.\"qualcuno\" get_gender_it def get_gender_it(word, raw_string='') Questa potrebbe non essere utile. In italiano per definire il genere \u00e8 necessario analizzare l'articolo che la precede e non la lettera con cui finisce la parola, ma sono presenti funzioni per la rimozione degli articoli dalla frase per semplificarne l'analisi TODO: verificare se utile isFractional_it def isFractional_it(input_str) This function takes the given text and checks if it is a fraction. E' la versione portoghese riadattata in italiano Args: text (str): the string to check if fractional Returns: (bool) or (float): False if not a fraction, otherwise the fraction TODO: verificare la corretta gestione dei plurali normalize_it def normalize_it(text, remove_articles) IT string normalization","title":"parse_it"},{"location":"tnalagmes.lang.parse_it/#module-tnalagmeslangparse_it","text":"Parse functions for Italian (IT-IT) TODO: numbers greater than 999999 TODO: it_number_parse TODO: it_pruning","title":"Module tnalagmes.lang.parse_it"},{"location":"tnalagmes.lang.parse_it/#datetime","text":"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.","title":"datetime"},{"location":"tnalagmes.lang.parse_it/#relativedelta","text":"The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect.","title":"relativedelta"},{"location":"tnalagmes.lang.parse_it/#extract95datetime95it","text":"def extract_datetime_it(string, currentDate)","title":"extract_datetime_it"},{"location":"tnalagmes.lang.parse_it/#extractnumber95it","text":"def extractnumber_it(text) Questa funzione prepara il testo dato per l'analisi rendendo numeri testuali come interi o frazioni. In italiano non \u00e8 un modo abituale ma pu\u00f2 essere interessante per Mycroft E' la versione portoghese riadattata in italiano args: text (str): la stringa da normalizzare Ritorna: (int) o (float): il valore del numero estratto","title":"extractnumber_it"},{"location":"tnalagmes.lang.parse_it/#extractnumber95long95it","text":"def extractnumber_long_it(word) Questa funzione converte un numero testuale lungo es. ventisette -> 27 quarantuno -> 41 nell'equivalente valore intero args: text (str): la stringa da normalizzare Ritorna: (int) : il valore del numero estratto usando tutta la parola Falso : se la parola non \u00e8 un numero es.\"qualcuno\"","title":"extractnumber_long_it"},{"location":"tnalagmes.lang.parse_it/#get95gender95it","text":"def get_gender_it(word, raw_string='') Questa potrebbe non essere utile. In italiano per definire il genere \u00e8 necessario analizzare l'articolo che la precede e non la lettera con cui finisce la parola, ma sono presenti funzioni per la rimozione degli articoli dalla frase per semplificarne l'analisi TODO: verificare se utile","title":"get_gender_it"},{"location":"tnalagmes.lang.parse_it/#isfractional95it","text":"def isFractional_it(input_str) This function takes the given text and checks if it is a fraction. E' la versione portoghese riadattata in italiano Args: text (str): the string to check if fractional Returns: (bool) or (float): False if not a fraction, otherwise the fraction TODO: verificare la corretta gestione dei plurali","title":"isFractional_it"},{"location":"tnalagmes.lang.parse_it/#normalize95it","text":"def normalize_it(text, remove_articles) IT string normalization","title":"normalize_it"},{"location":"tnalagmes.lang.parse_pt/","text":"Module tnalagmes.lang.parse_pt Parse functions for Portuguese (PT-PT) TODO: numbers greater than 999999 TODO: date time pt datetime datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. relativedelta The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect. extract_datetime_pt def extract_datetime_pt(input_str, currentDate) extractnumber_pt def extractnumber_pt(text) This function prepares the given text for parsing by making numbers consistent, getting rid of contractions, etc. Args: text (str): the string to normalize Returns: (int) or (float): The value of extracted number get_gender_pt def get_gender_pt(word, raw_string='') isFractional_pt def isFractional_pt(input_str) This function takes the given text and checks if it is a fraction. Args: text (str): the string to check if fractional Returns: (bool) or (float): False if not a fraction, otherwise the fraction normalize_pt def normalize_pt(text, remove_articles) PT string normalization pt_number_parse def pt_number_parse(words, i) pt_pruning def pt_pruning(text, symbols=True, accents=True, agressive=True)","title":"parse_pt"},{"location":"tnalagmes.lang.parse_pt/#module-tnalagmeslangparse_pt","text":"Parse functions for Portuguese (PT-PT) TODO: numbers greater than 999999 TODO: date time pt","title":"Module tnalagmes.lang.parse_pt"},{"location":"tnalagmes.lang.parse_pt/#datetime","text":"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.","title":"datetime"},{"location":"tnalagmes.lang.parse_pt/#relativedelta","text":"The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect.","title":"relativedelta"},{"location":"tnalagmes.lang.parse_pt/#extract95datetime95pt","text":"def extract_datetime_pt(input_str, currentDate)","title":"extract_datetime_pt"},{"location":"tnalagmes.lang.parse_pt/#extractnumber95pt","text":"def extractnumber_pt(text) This function prepares the given text for parsing by making numbers consistent, getting rid of contractions, etc. Args: text (str): the string to normalize Returns: (int) or (float): The value of extracted number","title":"extractnumber_pt"},{"location":"tnalagmes.lang.parse_pt/#get95gender95pt","text":"def get_gender_pt(word, raw_string='')","title":"get_gender_pt"},{"location":"tnalagmes.lang.parse_pt/#isfractional95pt","text":"def isFractional_pt(input_str) This function takes the given text and checks if it is a fraction. Args: text (str): the string to check if fractional Returns: (bool) or (float): False if not a fraction, otherwise the fraction","title":"isFractional_pt"},{"location":"tnalagmes.lang.parse_pt/#normalize95pt","text":"def normalize_pt(text, remove_articles) PT string normalization","title":"normalize_pt"},{"location":"tnalagmes.lang.parse_pt/#pt95number95parse","text":"def pt_number_parse(words, i)","title":"pt_number_parse"},{"location":"tnalagmes.lang.parse_pt/#pt95pruning","text":"def pt_pruning(text, symbols=True, accents=True, agressive=True)","title":"pt_pruning"},{"location":"tnalagmes.lang.parse_sv/","text":"Module tnalagmes.lang.parse_sv datetime datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. relativedelta The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect. extract_datetime_sv def extract_datetime_sv(string, currentDate) extractnumber_sv def extractnumber_sv(text) This function prepares the given text for parsing by making numbers consistent, getting rid of contractions, etc. Args: text (str): the string to normalize Returns: (int) or (float): The value of extracted number is_fractional_sv def is_fractional_sv(input_str) This function takes the given text and checks if it is a fraction. Args: input_str (str): the string to check if fractional Returns: (bool) or (float): False if not a fraction, otherwise the fraction normalize_sv def normalize_sv(text, remove_articles) English string normalization","title":"parse_sv"},{"location":"tnalagmes.lang.parse_sv/#module-tnalagmeslangparse_sv","text":"","title":"Module tnalagmes.lang.parse_sv"},{"location":"tnalagmes.lang.parse_sv/#datetime","text":"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.","title":"datetime"},{"location":"tnalagmes.lang.parse_sv/#relativedelta","text":"The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/> _ extension. However, notice that this type does NOT implement the same algorithm as his work. Do NOT expect it to behave like mx.DateTime's counterpart. There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:: relativedelta(datetime1, datetime2) The second one is passing it any number of the following keyword arguments:: relativedelta(arg1=x,arg2=y,arg3=z...) year, month, day, hour, minute, second, microsecond: Absolute information (argument is singular); adding or subtracting a relativedelta with absolute information does not perform an arithmetic operation, but rather REPLACES the corresponding value in the original datetime with the value(s) in relativedelta. years, months, weeks, days, hours, minutes, seconds, microseconds: Relative information, may be negative (argument is plural); adding or subtracting a relativedelta with relative information performs the corresponding aritmetic operation on the original datetime value with the information in the relativedelta. weekday: One of the weekday instances (MO, TU, etc). These instances may receive a parameter N, specifying the Nth weekday, which could be positive or negative (like MO(+1) or MO(-2). Not specifying it is the same as specifying +1. You can also use an integer, where 0=MO. Notice that if the calculated date is already Monday, for example, using MO(1) or MO(-1) won't change the day. leapdays: Will add given days to the date found, if year is a leap year, and the date found is post 28 of february. yearday, nlyearday: Set the yearday or the non-leap year day (jump leap days). These are converted to day/month/leapdays information. There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute). The order of attributes considered when this relativedelta is added to a datetime is: Year Month Day Hours Minutes Seconds Microseconds Finally, weekday is applied, using the rule described above. For example dt = datetime(2018, 4, 9, 13, 37, 0) delta = relativedelta(hours=25, day=1, weekday=MO(1)) datetime(2018, 4, 2, 14, 37, 0) First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect.","title":"relativedelta"},{"location":"tnalagmes.lang.parse_sv/#extract95datetime95sv","text":"def extract_datetime_sv(string, currentDate)","title":"extract_datetime_sv"},{"location":"tnalagmes.lang.parse_sv/#extractnumber95sv","text":"def extractnumber_sv(text) This function prepares the given text for parsing by making numbers consistent, getting rid of contractions, etc. Args: text (str): the string to normalize Returns: (int) or (float): The value of extracted number","title":"extractnumber_sv"},{"location":"tnalagmes.lang.parse_sv/#is95fractional95sv","text":"def is_fractional_sv(input_str) This function takes the given text and checks if it is a fraction. Args: input_str (str): the string to check if fractional Returns: (bool) or (float): False if not a fraction, otherwise the fraction","title":"is_fractional_sv"},{"location":"tnalagmes.lang.parse_sv/#normalize95sv","text":"def normalize_sv(text, remove_articles) English string normalization","title":"normalize_sv"},{"location":"tnalagmes.lang.phonemes_en/","text":"Module tnalagmes.lang.phonemes_en get_phonemes_en def get_phonemes_en(name) guess_phonemes_en def guess_phonemes_en(word)","title":"phonemes_en"},{"location":"tnalagmes.lang.phonemes_en/#module-tnalagmeslangphonemes_en","text":"","title":"Module tnalagmes.lang.phonemes_en"},{"location":"tnalagmes.lang.phonemes_en/#get95phonemes95en","text":"def get_phonemes_en(name)","title":"get_phonemes_en"},{"location":"tnalagmes.lang.phonemes_en/#guess95phonemes95en","text":"def guess_phonemes_en(word)","title":"guess_phonemes_en"},{"location":"tnalagmes.lang.translate/","text":"Module tnalagmes.lang.translate say_in_language def say_in_language(sentence, lang='en-us', wav_file='~/tnalagmes/translated') translate_text def translate_text(text, lang='en-us')","title":"translate"},{"location":"tnalagmes.lang.translate/#module-tnalagmeslangtranslate","text":"","title":"Module tnalagmes.lang.translate"},{"location":"tnalagmes.lang.translate/#say95in95language","text":"def say_in_language(sentence, lang='en-us', wav_file='~/tnalagmes/translated')","title":"say_in_language"},{"location":"tnalagmes.lang.translate/#translate95text","text":"def translate_text(text, lang='en-us')","title":"translate_text"},{"location":"tnalagmes.models.agents/","text":"Module tnalagmes.models.agents Agent None ChatAgent None Inventory what do you have how much money do you have how much are you worth NPC hello world what is your name attack take damage heal spend mana cast spell TNaLaGmesConstruct None TNaLaGmesEngine None export_game_data def export_game_data(path=None) get_entity def get_entity(text) import_game_data def import_game_data(path=None)","title":"agents"},{"location":"tnalagmes.models.agents/#module-tnalagmesmodelsagents","text":"","title":"Module tnalagmes.models.agents"},{"location":"tnalagmes.models.agents/#agent","text":"None","title":"Agent"},{"location":"tnalagmes.models.agents/#chatagent","text":"None","title":"ChatAgent"},{"location":"tnalagmes.models.agents/#inventory","text":"what do you have how much money do you have how much are you worth","title":"Inventory"},{"location":"tnalagmes.models.agents/#npc","text":"hello world what is your name attack take damage heal spend mana cast spell","title":"NPC"},{"location":"tnalagmes.models.agents/#tnalagmesconstruct","text":"None","title":"TNaLaGmesConstruct"},{"location":"tnalagmes.models.agents/#tnalagmesengine","text":"None","title":"TNaLaGmesEngine"},{"location":"tnalagmes.models.agents/#export95game95data","text":"def export_game_data(path=None)","title":"export_game_data"},{"location":"tnalagmes.models.agents/#get95entity","text":"def get_entity(text)","title":"get_entity"},{"location":"tnalagmes.models.agents/#import95game95data","text":"def import_game_data(path=None)","title":"import_game_data"},{"location":"tnalagmes.models.battle/","text":"Module tnalagmes.models.battle Ability what is your _name what is your cost what is your damage what are you generate some damage TNaLaGmesConstruct None","title":"battle"},{"location":"tnalagmes.models.battle/#module-tnalagmesmodelsbattle","text":"","title":"Module tnalagmes.models.battle"},{"location":"tnalagmes.models.battle/#ability","text":"what is your _name what is your cost what is your damage what are you generate some damage","title":"Ability"},{"location":"tnalagmes.models.battle/#tnalagmesconstruct","text":"None","title":"TNaLaGmesConstruct"},{"location":"tnalagmes.models.objects/","text":"Module tnalagmes.models.objects Calendar Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\" Inventory what do you have how much money do you have how much are you worth InventoryItem what are you what can you do how much are you worth ProgressTracker \"total distance\" \"current mileage\" \"add mileage\" \"subtract mileage\" \"are you completed?\" \"current difficulty TNaLaGmesConstruct None datetime datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. timedelta Difference between two datetime values.","title":"objects"},{"location":"tnalagmes.models.objects/#module-tnalagmesmodelsobjects","text":"","title":"Module tnalagmes.models.objects"},{"location":"tnalagmes.models.objects/#calendar","text":"Calendar Object \"What day/date/week/weekday/month/year is it?\" \"next turn\" \"how many turns left\" \"how many turns passed\" \"how many days per turn\" \"maximum number of turns\" \"increase speed\" \"decrease speed\" \"rollback X days/months/weeks/years\" \"advance X days/months/weeks/years\"","title":"Calendar"},{"location":"tnalagmes.models.objects/#inventory","text":"what do you have how much money do you have how much are you worth","title":"Inventory"},{"location":"tnalagmes.models.objects/#inventoryitem","text":"what are you what can you do how much are you worth","title":"InventoryItem"},{"location":"tnalagmes.models.objects/#progresstracker","text":"\"total distance\" \"current mileage\" \"add mileage\" \"subtract mileage\" \"are you completed?\" \"current difficulty","title":"ProgressTracker"},{"location":"tnalagmes.models.objects/#tnalagmesconstruct","text":"None","title":"TNaLaGmesConstruct"},{"location":"tnalagmes.models.objects/#datetime","text":"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.","title":"datetime"},{"location":"tnalagmes.models.objects/#timedelta","text":"Difference between two datetime values.","title":"timedelta"},{"location":"tnalagmes.models.world/","text":"Module tnalagmes.models.world Agent None Inventory what do you have how much money do you have how much are you worth PhysicsEngine None Scene None TNaLaGmesEngine None export_game_data def export_game_data(path=None) get_entity def get_entity(text) import_game_data def import_game_data(path=None) World None","title":"world"},{"location":"tnalagmes.models.world/#module-tnalagmesmodelsworld","text":"","title":"Module tnalagmes.models.world"},{"location":"tnalagmes.models.world/#agent","text":"None","title":"Agent"},{"location":"tnalagmes.models.world/#inventory","text":"what do you have how much money do you have how much are you worth","title":"Inventory"},{"location":"tnalagmes.models.world/#physicsengine","text":"None","title":"PhysicsEngine"},{"location":"tnalagmes.models.world/#scene","text":"None","title":"Scene"},{"location":"tnalagmes.models.world/#tnalagmesengine","text":"None","title":"TNaLaGmesEngine"},{"location":"tnalagmes.models.world/#export95game95data","text":"def export_game_data(path=None)","title":"export_game_data"},{"location":"tnalagmes.models.world/#get95entity","text":"def get_entity(text)","title":"get_entity"},{"location":"tnalagmes.models.world/#import95game95data","text":"def import_game_data(path=None)","title":"import_game_data"},{"location":"tnalagmes.models.world/#world","text":"None","title":"World"},{"location":"tnalagmes.util.log/","text":"Module tnalagmes.util.log LOG Custom logger class that acts like logging.Logger The logger name is automatically generated by the module of the caller Usage: >>> LOG.debug('My message: %s', debug_str) 13:12:43.673 - : :1 - DEBUG - My message: hi >>> LOG('custom_name').debug('Another message') 13:13:10.462 - custom_name - DEBUG - Another message create_logger def create_logger(name) debug def debug(*args, **kwargs) Log 'msg % args' with severity 'DEBUG'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=1) error def error(*args, **kwargs) Log 'msg % args' with severity 'ERROR'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.error(\"Houston, we have a %s\", \"major problem\", exc_info=1) exception def exception(*args, **kwargs) Convenience method for logging an ERROR with exception information. info def info(*args, **kwargs) Log 'msg % args' with severity 'INFO'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1) init def init() warning def warning(*args, **kwargs) Log 'msg % args' with severity 'WARNING'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=1)","title":"log"},{"location":"tnalagmes.util.log/#module-tnalagmesutillog","text":"","title":"Module tnalagmes.util.log"},{"location":"tnalagmes.util.log/#log","text":"Custom logger class that acts like logging.Logger The logger name is automatically generated by the module of the caller Usage: >>> LOG.debug('My message: %s', debug_str) 13:12:43.673 - : :1 - DEBUG - My message: hi >>> LOG('custom_name').debug('Another message') 13:13:10.462 - custom_name - DEBUG - Another message","title":"LOG"},{"location":"tnalagmes.util.log/#create95logger","text":"def create_logger(name)","title":"create_logger"},{"location":"tnalagmes.util.log/#debug","text":"def debug(*args, **kwargs) Log 'msg % args' with severity 'DEBUG'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=1)","title":"debug"},{"location":"tnalagmes.util.log/#error","text":"def error(*args, **kwargs) Log 'msg % args' with severity 'ERROR'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.error(\"Houston, we have a %s\", \"major problem\", exc_info=1)","title":"error"},{"location":"tnalagmes.util.log/#exception","text":"def exception(*args, **kwargs) Convenience method for logging an ERROR with exception information.","title":"exception"},{"location":"tnalagmes.util.log/#info","text":"def info(*args, **kwargs) Log 'msg % args' with severity 'INFO'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1)","title":"info"},{"location":"tnalagmes.util.log/#init","text":"def init()","title":"init"},{"location":"tnalagmes.util.log/#warning","text":"def warning(*args, **kwargs) Log 'msg % args' with severity 'WARNING'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=1)","title":"warning"},{"location":"tnalagmes.util.nlp/","text":"Module tnalagmes.util.nlp LOG Custom logger class that acts like logging.Logger The logger name is automatically generated by the module of the caller Usage: >>> LOG.debug('My message: %s', debug_str) 13:12:43.673 - : :1 - DEBUG - My message: hi >>> LOG('custom_name').debug('Another message') 13:13:10.462 - custom_name - DEBUG - Another message create_logger def create_logger(name) debug def debug(*args, **kwargs) Log 'msg % args' with severity 'DEBUG'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=1) error def error(*args, **kwargs) Log 'msg % args' with severity 'ERROR'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.error(\"Houston, we have a %s\", \"major problem\", exc_info=1) exception def exception(*args, **kwargs) Convenience method for logging an ERROR with exception information. info def info(*args, **kwargs) Log 'msg % args' with severity 'INFO'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1) init def init() warning def warning(*args, **kwargs) Log 'msg % args' with severity 'WARNING'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=1) NER def NER(text) replace_coreferences def replace_coreferences(text) textual_entailment def textual_entailment(premise, hypothesis) Textual Entailment (TE) takes a pair of sentences and predicts whether the facts in the first necessarily imply the facts in the second one. The AllenNLP toolkit provides the following TE visualization, which can be run for any TE model you develop. This page demonstrates a reimplementation of the decomposable attention model (Parikh et al, 2017) , which was state of the art for the SNLI benchmark (short sentences about visual scenes) in 2016. Rather than pre-trained Glove vectors, this model uses ELMo embeddings, which are completely character based and improve performance by 2% :param premise: :param hypotheses: :return:","title":"nlp"},{"location":"tnalagmes.util.nlp/#module-tnalagmesutilnlp","text":"","title":"Module tnalagmes.util.nlp"},{"location":"tnalagmes.util.nlp/#log","text":"Custom logger class that acts like logging.Logger The logger name is automatically generated by the module of the caller Usage: >>> LOG.debug('My message: %s', debug_str) 13:12:43.673 - : :1 - DEBUG - My message: hi >>> LOG('custom_name').debug('Another message') 13:13:10.462 - custom_name - DEBUG - Another message","title":"LOG"},{"location":"tnalagmes.util.nlp/#create95logger","text":"def create_logger(name)","title":"create_logger"},{"location":"tnalagmes.util.nlp/#debug","text":"def debug(*args, **kwargs) Log 'msg % args' with severity 'DEBUG'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=1)","title":"debug"},{"location":"tnalagmes.util.nlp/#error","text":"def error(*args, **kwargs) Log 'msg % args' with severity 'ERROR'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.error(\"Houston, we have a %s\", \"major problem\", exc_info=1)","title":"error"},{"location":"tnalagmes.util.nlp/#exception","text":"def exception(*args, **kwargs) Convenience method for logging an ERROR with exception information.","title":"exception"},{"location":"tnalagmes.util.nlp/#info","text":"def info(*args, **kwargs) Log 'msg % args' with severity 'INFO'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1)","title":"info"},{"location":"tnalagmes.util.nlp/#init","text":"def init()","title":"init"},{"location":"tnalagmes.util.nlp/#warning","text":"def warning(*args, **kwargs) Log 'msg % args' with severity 'WARNING'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=1)","title":"warning"},{"location":"tnalagmes.util.nlp/#ner","text":"def NER(text)","title":"NER"},{"location":"tnalagmes.util.nlp/#replace95coreferences","text":"def replace_coreferences(text)","title":"replace_coreferences"},{"location":"tnalagmes.util.nlp/#textual95entailment","text":"def textual_entailment(premise, hypothesis) Textual Entailment (TE) takes a pair of sentences and predicts whether the facts in the first necessarily imply the facts in the second one. The AllenNLP toolkit provides the following TE visualization, which can be run for any TE model you develop. This page demonstrates a reimplementation of the decomposable attention model (Parikh et al, 2017) , which was state of the art for the SNLI benchmark (short sentences about visual scenes) in 2016. Rather than pre-trained Glove vectors, this model uses ELMo embeddings, which are completely character based and improve performance by 2% :param premise: :param hypotheses: :return:","title":"textual_entailment"},{"location":"tnalagmes.util.phonemes/","text":"Module tnalagmes.util.phonemes get_phonemes def get_phonemes(name, lang='en-us') guess_phonemes def guess_phonemes(word, lang='en-us') NOTES: guessing phonemes rule-based","title":"phonemes"},{"location":"tnalagmes.util.phonemes/#module-tnalagmesutilphonemes","text":"","title":"Module tnalagmes.util.phonemes"},{"location":"tnalagmes.util.phonemes/#get95phonemes","text":"def get_phonemes(name, lang='en-us')","title":"get_phonemes"},{"location":"tnalagmes.util.phonemes/#guess95phonemes","text":"def guess_phonemes(word, lang='en-us') NOTES: guessing phonemes rule-based","title":"guess_phonemes"},{"location":"tnalagmes.util.signal/","text":"Module tnalagmes.util.signal LOG Custom logger class that acts like logging.Logger The logger name is automatically generated by the module of the caller Usage: >>> LOG.debug('My message: %s', debug_str) 13:12:43.673 - : :1 - DEBUG - My message: hi >>> LOG('custom_name').debug('Another message') 13:13:10.462 - custom_name - DEBUG - Another message create_logger def create_logger(name) debug def debug(*args, **kwargs) Log 'msg % args' with severity 'DEBUG'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=1) error def error(*args, **kwargs) Log 'msg % args' with severity 'ERROR'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.error(\"Houston, we have a %s\", \"major problem\", exc_info=1) exception def exception(*args, **kwargs) Convenience method for logging an ERROR with exception information. info def info(*args, **kwargs) Log 'msg % args' with severity 'INFO'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1) init def init() warning def warning(*args, **kwargs) Log 'msg % args' with severity 'WARNING'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=1) check_for_signal def check_for_signal(signal_name, sec_lifetime=0) See if a named signal exists Args: signal_name (str): The signal's name. Must only contain characters valid in filenames. sec_lifetime (int, optional): How many seconds the signal should remain valid. If 0 or not specified, it is a single-use signal. If -1, it never expires. Returns: bool: True if the signal is defined, False otherwise create_file def create_file(filename) Create the file filename and create any directories needed Args: filename: Path to the file to be created create_signal def create_signal(signal_name) Create a named signal Args: signal_name (str): The signal's name. Must only contain characters valid in filenames. ensure_directory_exists def ensure_directory_exists(directory, domain=None) Create a directory and give access rights to all Args: domain (str): The IPC domain. Basically a subdirectory to prevent overlapping signal filenames. Returns: str: a path to the directory get_ipc_directory def get_ipc_directory(domain=None, dir=None) Get the directory used for Inter Process Communication Files in this folder can be accessed by different processes on the machine. Useful for communication. This is often a small RAM disk. Args: domain (str): The IPC domain. Basically a subdirectory to prevent overlapping signal filenames. Returns: str: a path to the IPC directory","title":"signal"},{"location":"tnalagmes.util.signal/#module-tnalagmesutilsignal","text":"","title":"Module tnalagmes.util.signal"},{"location":"tnalagmes.util.signal/#log","text":"Custom logger class that acts like logging.Logger The logger name is automatically generated by the module of the caller Usage: >>> LOG.debug('My message: %s', debug_str) 13:12:43.673 - : :1 - DEBUG - My message: hi >>> LOG('custom_name').debug('Another message') 13:13:10.462 - custom_name - DEBUG - Another message","title":"LOG"},{"location":"tnalagmes.util.signal/#create95logger","text":"def create_logger(name)","title":"create_logger"},{"location":"tnalagmes.util.signal/#debug","text":"def debug(*args, **kwargs) Log 'msg % args' with severity 'DEBUG'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=1)","title":"debug"},{"location":"tnalagmes.util.signal/#error","text":"def error(*args, **kwargs) Log 'msg % args' with severity 'ERROR'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.error(\"Houston, we have a %s\", \"major problem\", exc_info=1)","title":"error"},{"location":"tnalagmes.util.signal/#exception","text":"def exception(*args, **kwargs) Convenience method for logging an ERROR with exception information.","title":"exception"},{"location":"tnalagmes.util.signal/#info","text":"def info(*args, **kwargs) Log 'msg % args' with severity 'INFO'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1)","title":"info"},{"location":"tnalagmes.util.signal/#init","text":"def init()","title":"init"},{"location":"tnalagmes.util.signal/#warning","text":"def warning(*args, **kwargs) Log 'msg % args' with severity 'WARNING'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=1)","title":"warning"},{"location":"tnalagmes.util.signal/#check95for95signal","text":"def check_for_signal(signal_name, sec_lifetime=0) See if a named signal exists Args: signal_name (str): The signal's name. Must only contain characters valid in filenames. sec_lifetime (int, optional): How many seconds the signal should remain valid. If 0 or not specified, it is a single-use signal. If -1, it never expires. Returns: bool: True if the signal is defined, False otherwise","title":"check_for_signal"},{"location":"tnalagmes.util.signal/#create95file","text":"def create_file(filename) Create the file filename and create any directories needed Args: filename: Path to the file to be created","title":"create_file"},{"location":"tnalagmes.util.signal/#create95signal","text":"def create_signal(signal_name) Create a named signal Args: signal_name (str): The signal's name. Must only contain characters valid in filenames.","title":"create_signal"},{"location":"tnalagmes.util.signal/#ensure95directory95exists","text":"def ensure_directory_exists(directory, domain=None) Create a directory and give access rights to all Args: domain (str): The IPC domain. Basically a subdirectory to prevent overlapping signal filenames. Returns: str: a path to the directory","title":"ensure_directory_exists"},{"location":"tnalagmes.util.signal/#get95ipc95directory","text":"def get_ipc_directory(domain=None, dir=None) Get the directory used for Inter Process Communication Files in this folder can be accessed by different processes on the machine. Useful for communication. This is often a small RAM disk. Args: domain (str): The IPC domain. Basically a subdirectory to prevent overlapping signal filenames. Returns: str: a path to the IPC directory","title":"get_ipc_directory"},{"location":"tnalagmes.util.time/","text":"Module tnalagmes.util.time datetime datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. tzlocal A :class: tzinfo subclass built around the time timezone functions. default_timezone def default_timezone() Get the default timezone Returns: (datetime.tzinfo): Definition of the default timezone get_timedelta def get_timedelta(dt, anchor=None) Get a datetime object or a int() Epoch timestamp and return a timedelta now_local def now_local(tz=None) Retrieve the current time Args: tz (datetime.tzinfo, optional): Timezone, default to user's settings Returns: (datetime): The current time now_utc def now_utc() Retrieve the current time in UTC Returns: (datetime): The current time in Universal Time, aka GMT to_local def to_local(dt) Convert a datetime to the user's local timezone Args: dt (datetime): A datetime (if no timezone, defaults to UTC) Returns: (datetime): time converted to the local timezone to_utc def to_utc(dt) Convert a datetime with timezone info to a UTC datetime Args: dt (datetime): A datetime (presumably in some local zone) Returns: (datetime): time converted to UTC","title":"time"},{"location":"tnalagmes.util.time/#module-tnalagmesutiltime","text":"","title":"Module tnalagmes.util.time"},{"location":"tnalagmes.util.time/#datetime","text":"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.","title":"datetime"},{"location":"tnalagmes.util.time/#tzlocal","text":"A :class: tzinfo subclass built around the time timezone functions.","title":"tzlocal"},{"location":"tnalagmes.util.time/#default95timezone","text":"def default_timezone() Get the default timezone Returns: (datetime.tzinfo): Definition of the default timezone","title":"default_timezone"},{"location":"tnalagmes.util.time/#get95timedelta","text":"def get_timedelta(dt, anchor=None) Get a datetime object or a int() Epoch timestamp and return a timedelta","title":"get_timedelta"},{"location":"tnalagmes.util.time/#now95local","text":"def now_local(tz=None) Retrieve the current time Args: tz (datetime.tzinfo, optional): Timezone, default to user's settings Returns: (datetime): The current time","title":"now_local"},{"location":"tnalagmes.util.time/#now95utc","text":"def now_utc() Retrieve the current time in UTC Returns: (datetime): The current time in Universal Time, aka GMT","title":"now_utc"},{"location":"tnalagmes.util.time/#to95local","text":"def to_local(dt) Convert a datetime to the user's local timezone Args: dt (datetime): A datetime (if no timezone, defaults to UTC) Returns: (datetime): time converted to the local timezone","title":"to_local"},{"location":"tnalagmes.util.time/#to95utc","text":"def to_utc(dt) Convert a datetime with timezone info to a UTC datetime Args: dt (datetime): A datetime (presumably in some local zone) Returns: (datetime): time converted to UTC","title":"to_utc"}]}